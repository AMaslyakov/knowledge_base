# Git 

## Введение

Для любой разработки требуется сохранение кода и контроль версий.
Утилита которая позволяет управлять и отслеживать разными версиями кода называется системой контроля версий.

Рассмотрим программу git, для управления контролем версий. 

## Пакеты git(linux)

Для переноса из других vcs(version control system), могут потребоваться пакеты:
```
git-arch
git-cvs
git-svn
```
Название пакетов в разных дистрибутивах могут отличаться.

Для графического представления истории репозитория могут пригодиться пакеты:
```
git-gui
gitk
gitweb
```
Для отправки патчей посредством email понадобится пакет:

```
git-email
```

## Установка в Windows

Для установки git в Windows. Можно установить:

[https://git-scm.com/download/win](https://git-scm.com/download/win)

Либо Cygwing git:

[https://cygwing.com](https://cygwing.com)


Либо пакет msysGit:

[https://gitforwindows.org/](https://gitforwindows.org/)

## Как хранятся изменения внутри git

Данные репозитория хранятся в директории ```.git```. Git управляет хранилищем объектов и индексом.

Хранилище объектов содержит четыре типа объектов:

- BLOB(Binary Large Object) содержит данные без метаданных
- Деревья. Дерево представляет один уровень, записывает id блобов, имена путей, небольшие метаданные для всех файлов в каталоге
- Коммиты хранят метаданные изменений(имя автора, дату, сообщение коммита) Каждый коммит ссылается на снимок состояния репозитория (объект дерева). Обычные коммиты имеют одного родителя, но возможны и коммиты с несколькими родителями (например, при слиянии веток).  
- Теги человекочитаемое имя назначаемое объекту, обычно коммитам. Например Ver.-1.0

## Индекс

В git это временный и динамический бинарный файл, который описывает структуру каталогов всего репозитория. В частности, индекс получает версию полной структуры проекта в некоторый момент времени.

Git позволяет изменять содержимое индекса четко определенными действиями.

Индекс хранит изменения до коммита.
Изменяется с помощью добавления, удаления, редактирования фпйлов.

## Идентификаторы объектов

Хранилище объектов git организовано в виде ассоциативной системы хранения. Каждому объекту присваивается уникальное имя - идентификатор, на основе алгоритма SHA1. Идентфикатор объекта представляется в виде 40-разрядного 16-ричного числа. Часто его еще называют _хэшкод_.
Хэшкод вычисляется на основе содержимого объекта. Если содержимое объектов идентично они имеют одинаковый хэшкод.

## Отслеживание контента

Благодаря идентификаторам, git может отслеживать контент. Если в репозитории существует два идентичных файла, то для них в хранилище будет создан один BLOB с хэшкодом вычисленным на основе содержимого.

Если один из файлов после изменений будет иметь отличия, соответственно создаться новый BLOB с новым идентификатором объекта.

## Путь vs. Содержание

Git имеет собственную структуру хранилища, которая не основывается на именах и путях файлов. Внутренняя структура git более эффективна для собственных операций над объектами. И она позволяет точно воспроизвести файлы и каталоги проекты проиндексированные хэшем.

## Pack-файлы


Git умно упаковывает файлы. Он находит файлы похожие по содержанию и сохраняет полностью только один файл. Другой файл сохраняется в хранилище в виде дельты, т.е. сохраняется только разница содержимого между первым и вторым файлом.

## Управление индексом

Состояние индекса можно узнать в любой момент с помощью команды:

```git status```

Файлы классифицируются на:

-  отслеживаемые(tracked)
-  игнорируемые(ignored)
-  неотслеживаемые(untracked)

*Отслеживаемые* файлы уже находятся в репозитории

*Игнорируемые* явно объявленные файлы и деректории в .gitignore 

*Неотслеживаемые* файлы которые не добавлены в индекс и отсутствуют в .gitignore


### git add

Добавляет файл(ы) в индекс. Т.е. файл(ы) становится отслеживаемым(и). Также добавляет изменения для уже отслеживаемых файлов.

### git commit

Производится фиксация изменений добавленных в индекс.

Команда ```git commit --all``` автоматически добавляет в индекс изменения отслеживаемых файлов и сразу создает коммит. Не отслеживаемые файлы при этом не меняют свой статус.

Если не указать опцию ```-m``` git запустит редактор указанный в конфигурации для создания коммита.


### git rm

Команда удаляет файлы из индекса и из каталога. Либо удаляет файлы только  из индекса. Не может удалить файлы только с диска(для этого нужно использовать системную команду), т.е. команда работает только с файлами добавленными в репозиторий.

Команда:

```git rm --cached```

Удаляет файл из индекса. Т.е. делает файл неотслеживаемым. 

Но команда ```git rm ``` удалит файл и из индекса и с диска до коммита и после коммита.

Команда:

```git rm -f``` 

Удалит даже отслеживаемый модифицированный файл не добавленный в индекс.

Для восстановления файла удаленного командой ```git rm``` можно использовать механизм восстановления файлов:

```git checkout HEAD -- <file>```

### git mv


Позволяет перемещать и переименовывать файлы находящиеся репозитории или в индексе.

Синтаксис:

```git mv  <file1> <file2>```

## .gitignore

Содержит список файлов и шаблонов которые нужно игнорировать. 


### Формат .gitignore

```# Files``` -- комментарий

```\#file.txt``` -- если название файла начинается с решетки

```file.txt``` -- имена файлов полном виде

```dir/``` -- каталог отмечается следующим образом

```*``` -- заменяет любые символы

Например:

```*.txt``` -- игнорировать все файлы с расширением ```.txt```

```!``` -- задает исключение для общего правила заданного с помощью предшествующего правила.

Например:

```
logs/
!logs/log.txt
```

Игнорирует папку logs и все содержимое, но отслеживает logs/log.txt

```
*.txt
!history.txt
```

Игнорирует все файлы txt, но отслеживает history.txt

Файлы .gitignore можно создавать в любом каталоге репозитория. Каждый файл влияет только на свой каталог и все подкаталоги. Правила .gitignore каскадные, определив общее правило в каталоге высокого уровня, его можно отменять с помощью ```!``` в подкаталогах.

### Приоритет игнорирования

- Шаблоны определенные в командной строке ???
- Шаблоны из файла в верхнем каталоге
- Шаблоны в родительских каталогах, они будут перезаписаны с помощью .gitignore более высокого уровня
- Шаблоны из файла ```.git/info/exclude```
- Шаблоны из файла указанного переменной конфигурации ```core.excludefile```  

*exclude* -- содержит шаблоны как и в .gitignore. Позволяет игнорировать специфичные файлы характерные для операционной системы или ПО, но в .gitignore репозитория отмечать файлы характерные только для его специфики.

## Коммиты(фиксации)

Коммит это добавление изменений в репозитрий. Git сравнивает ткущее состояние индекса с предыдущим и получает список добавленых/измененых/удаленных файлов
/каталогов. Если файл/каталог изменился создается новый BLOB, если не изменился используются имеющиеся блобы.

Коммиты объденяются в цепочку, в которой каждый новый коммит указывает на превдшественика.

Коммит это единственный способ представления изменений в репозиторий.

Git нормально относится к частым коммитам и обеспечивает богатый набор комманд для управления ими.

### Атомарные наборы изменений

Разработчик отправляющий изменения в репозиторий должен стремится чтобы каждый коммит представлял собой атомарный(неделимый) набор изменений не зависимо от количества созданых/модифицированных/удаленных файлов/каталогов. 


Пример на Python, иллюстрирующий разницу между неатомарным и атомарным переносом функции между файлами:

### Исходное состояние

**file_a.py**
```python
def foo():
    print("foo из file_a")

def bar():
    print("bar из file_a")
```

**file_b.py**
```python
def baz():
    print("baz из file_b")
```

**main.py**
```python
from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
```

## Пример 1: Неатомарный перенос (код не работает)

**Шаг 1.** Удаляем функцию `foo` из `file_a.py` (делаем коммит).

**file_a.py**
```python
def bar():
    print("bar из file_a")
```

**file_b.py** (без изменений)
```python
def baz():
    print("baz из file_b")
```

**main.py** (без изменений)
```python
from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
```

**Результат:**  
При запуске `main.py` возникает ошибка:
> ImportError: cannot import name 'foo' from 'file_a'

**Причина:**  
Функция удалена, но импорт в main.py не изменён. Код не работает.

## Пример 2: Атомарный перенос (код работает)

**Шаг 1.** Переносим функцию `foo` в `file_b.py` и корректируем все импорты (делаем один атомарный коммит).

**file_a.py**
```python
def bar():
    print("bar из file_a")
```

**file_b.py**
```python
def baz():
    print("baz из file_b")

def foo():
    print("foo из file_b")
```

**main.py**
```python
from file_a import bar
from file_b import baz, foo

foo()
bar()
baz()
```

**Результат:**  
Код запускается без ошибок, все функции доступны и работают как ожидается.

**Вывод:**  
В первом случае коммит неатомарный — функция удалена, но не добавлена в новый файл и не исправлены импорты, из-за чего код ломается.  
Во втором случае коммит атомарный — все изменения внесены одновременно, код всегда находится в рабочем состоянии. 

Git все равно как сделан коммит, но если не учитывать атомарность фиксаций, репозиторий будет иметь переходные состояния.

## Идентификация фиксаций.

Как и любой объект в git коммит имеет идентификатор - хэш-код.

Идентификаторы нужны для создания веток, для сравнения двух веток, для 
изменения истории коммитов


### Абсолютные имена фиксации

Хэш-код коммита -- это абсолютное имя которое относится только к одному коммиту. Такой идентификатор *глобален*. Если есть два коммитс с одинаковым именем в двух разных репозиториях, это значит что их содержимое одинаково.

Для удобства 40-значное абсолютное имя коммита сокращается до 6 знаков при использовании коммандами Git. 

```
git log -1 --pretty=oneline HEAD
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
```

```
git log -1 --pretty=oneline 3e7d33
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
```

### Ссылки и символьные ссылки

Хэшкод является ссылкой относящейся к объекту.

Символическая ссылка это имя коссвенно указывающее на объект.

Локальные имена ветки, удаленные имена ветки, имена тэгов -- все это ссылки.

У символической ссылки есть явное - полное имя, которое хранится в каталоге .git/refs/

Обычно представлено три пространства имен:
- refs/heads/refs - локальные ветки
- refs/remotes/ref - удаленные ветки 
- refs/tag/ref - теги

Например для локальной ветки dev, будет соотвеовать ссылка:
    
    refs/heads/dev

Для удаленой ветки origin/master, соответсовать:

    refs/remotes/origin/master

Для тега v2.6.23, будет соотвествовать ссылка:

    refs/tags/v2.6.23

Если тег и ветка будут иметь одинаковые имена, то порядок поиска ссылок будет проходить как:

-    .git/ref(Для специальных ссылок HEAD, ORIG_HEAD...)
-    .git/refs/ref
-    .git/refs/tags/ref
-    .git/refs/heads/ref
-    .git/refs/remotes/ref
-    .git/refs/remotes/ref/HEAD


### Специальные символьные ссылки 

**HEAD** указывает на самую последнюю фиксацию в текущей ветке. 
За исключением ситуации, detach HEAD, при переключении на какой-либо коммит. Detach HEAD будет указывать на переключенный коммит. detach -- говорит о том, что HEAD не прикреплен к конкретной ветке.

**ORIG_HEAD** такие операции как merge revert записывают предыдущию версию HEAD в ORIG_HEAD. Данную ссылку можно использовать для восстановления предыдущего состяния или сравнения.

**FETCH_HEAD** сюда команда ```git fetch``` записывает головы всех удаленных веток. Ссылка доступна после опреции fetch

**MERGE_HEAD** указывает на вершину ветки с которой было сделано слияние. Ссылка доступна после слияния.

Все символические ссылки управляются командой ```git symbolic-ref``` 

### Относительные имена фиксаций

Для быстрого выполнения команд и навигации между комиттами git предлагает механизм относительных имен. С помощью символово ```~``` и ```^```.

Совместно с этими символами можно использовать символьные ссылки ```HEAD```, имена веток, сокращенный хэшкод.

Предыдущий коммит в main:

```main^``` или ```main~``` или ```main~1```

Предыдущий от предидущего:

```main^^``` или ```main~2```


При слиянии у коммттов могут образовываться родители 2 и болле. ```^``` используется для навигации по родителям коммта. 
Первый родитель коммита:

```main^``` или ```main^1```

Второй родитель коммита:

```main^2``` 

Данные обозначения можно комбинировать. Например:

```main~9^2~3^4```

Используя:

```git show-branch --more=10```

Можно изучать структуру графа репозитория и иследовать слодные слияния. 

## История фиксаций

### Просмотр коммитов

Основная команда для просмотра коммитов:

```git log```

Запись без параметров аналгоична комманде:

```git log HEAD```

Выводит исторю коммитов в обратном хронологическом порядке, от коммита HEAD. Но нужно помниить, что при перемещении по истории ккоммитов git придерживается их графика, а не времени.


Вывод ```git log``` можно менять с помощью аргумента ```--pretty```. Можно выбрать формат вывода из готовых вартантов (full, short, oneline). Или задать формат с помощью значения format.

Примеры:

```git log --pretty=short main```

```
commit f068b66b1332771771ddc0cbdf55da2ac4c4add5
Author: AMaslyakov <A.V.Masliakov@urfu.me>

    Relative names
```

```git log --pretty=format:"Хэш: %H сокращенный хэш:%h"```

```Хэш: f068b66b1332771771ddc0cbdf55da2ac4c4add5, сокращелнный хэш: f068b66```

Можно ограничить вывод истории между несколькими коммитами:

```git log --pretty=short  main~12..main~10```

Покажет историю между 10-м и 11-м коммитом в main в формате 
short.

Комманда:

```git log -1 -p 4а3688```

Выведет изменения созданные в коммите

Атрибут ```--stat``` добавит иноформацию о количестве измененных файлов и количестве добавленных и удаленных строк.

Коммандой:

```git show <commit>```

можно просматривать конкретные коммиты.

## Графы коммитов

Коммиты внутри git связываются в один большой граф. Данный граф называется DAG графом(direct acyclic graph, направленый ациклический граф). В таком графе коммиты являются вершинами, которые имеют однонаправленую связь в виде ребра, от последнего коммита к предыдущему(предыдущим если 2 и более родителей).

DAG имеет два важных свойства:

1. Ребра однонаправлены

1. Если начать обход по ребрам с любой вершины, то обратного пути для возвращения в исходную вершину не существует.

На истори коммитов ниже, время идет слева на право. Но для гит не имеет значение когда были сделаны коммиты E и C. Коммиты могли быть сделаны в разных часовых поясах. 
Ветка master состоит из коммитов: A, B, C, D, H.
Ветка pr17  состоит из коммитов  A, B, E, F, G.

После слияния веток master будет указывать на коммит H, а pr17 так и будет указывать на G, как было до слияния.

```
         E<--F<--G 
        /         \
A <-- B<--C<--D<--H 

G - pr17 branch
H - master

```

### Понимание DAG коммитов

- У каждого коммита может быть 0 и более родителей

- У обычных коммитов есть только один родитель

- У начальной фиксации(коммита) нет родителей, т.е. их 0

- У merge коммита болле одного родителя

- Коммит у которого два и более  потомка(ребенка/children) формирует ветку. Для примера выше это коммит B


### Диапазонны фиксаций

Для изучения ветки или части ветки, в гит можно использовать диапазоны коммитов. Рассмотрим пример для ветки M.

 ```M~14<-M~13<-M~12<-M~11-M~10<-M~9```

Где ```M~14``` самый старый коммит на даннм отрезке ветки, а ```M~9``` самый новый на данном отрезке

Диапазон коммитов обозначается как ```<start>..<end>``` например:

```M~12..M~10``` -- что соответствует двум коммитам ```M~10, M~11```. ```M~12```не включен в диапазон. Так устроенно из-за определения диапазона коммитов в git -- это набор коммитов достижимых с конца(end), но не достижимых с начала(start). Другими словами end, включен в диапазон, а start не включен. 
Математически:

<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo>(</mo>
  <mi>start</mi>
  <mo>;</mo>
  <mi>end</mi>
  <mo>]</mo>
</math>


При этом напрвление start end соотвесьвуют хронологическому порядку. Start старше, чем end. Но при этом не включение start в диапазон, обозначает направление связей от end в сторону старших коммитов.

## Достижимость в графах

Коммит X достижим из коммита Y, когда можно пойти из коммита Y по дугам графа, по направления ребер и прийти в коммит X.

Достижимость коммитов используется например для комманды ```git log```.

Пусть имеется репозиторй с двумя ветками: mian и branch. Произведено слияние из branch в main.Тогда:

```
            D(branch)  
           /   \    
A <- B <- C <-  E <- F(main)
```

Команда ```git log main``` выведет исторю для всех достижимых узлов: F, E, D, C, B, A. 

Команда ```git log branch```выведет историю для достижимых узлов: D, C, B, A.


Пусть имеется репозиторй с двумя ветками: mian и branch. Но слияние произведено из main в branch.Тогда:

```
            D <- G(branch)  
           /     /  
A <- B <- C <-  E <- F(main)
```

Команда ```git log main``` покажет историю из: F, E, C, B, A. Коммиты D, G будут не достижимы из F.

Команда ```git log branch``` покажет историю из: G, E, D, C, B, A. Из G будет не достижим только коммит F.

### Исключение коммитов и веток

Для того чтобы исключить коммит и все достижимые из него узлы используется префикс ```^```(в отличие от постфикса, указание на родителя).

Например для ветки:

```A <- B <- C <- main```

```git log ^B main```

Будет выведено: main, C.

При этом порядок не важен:
                                ```git log  main ^B```

Данная команда эквивалентна команде:

```git log B..main```

Рассмотрим диапазон конкретнее на других примерах.


```
      <-G<-D(branch)
           /(merge to branch)   
A <- B <- C <-  E <- F(main)

```

Команда ```git log branch..main``` выведет: F(main), E.
Все узлы достижимые из branch, включая узел C в котором ветка branch была создана, будут исключены. 

Для случая:
```
    W<-X<-Y <-Z (branch)
      /        \
A <- B <- C <-  D(main)

```

Команда ```git log branch..main``` выведет: D(main), C. Потомучто все узлы достижимые из branch будут исключены, в том числе и Z(branch)

Диапазон можно задавать в коротком варианте: ```start..```, ```..end```. Что эквивалентно ```start..HEAD```, ```HEAD..end``` соотвественно.

Так же запись диапазонна можно рассматривать как разницу:

```A <- B <- C <- main```


```git log B..main```


```A <- B
          C - main```


### Симметричный диапазон(симметричная разница)

Получается с помощью символа ```a...b``` - троеточие. Выводит те узлы которые доступны только  из start или доступны только из end, но не одновременно. При этом узлы a, b не являбтся ни концом ни началом. Поэтому  ```b...a``` будет эквивалентно ```a...b```

```
A <- B <- C <- D<- E <-F<-G(main)
              \      /
               U <- V <-X <-Y(dev)
```

Из main достижимы:
(G), (F), V, U, C, (E), (D), B, A
Из dev достижимы|
(Y), (X), V, U, C, B, A.

в скобках помечены коммиты, которых нет в другой ветке.

Соответсвенно команда ```git log dev...main```, выведет коммииты: D, E, F, X, Y, G

## Поиск коммитов

### git bisect


`git bisect` — это инструмент Git для **поиска коммита, в котором впервые появился баг или регрессия**. Он использует **бинарный поиск** по истории коммитов, что позволяет значительно сократить время поиска проблемного изменения.

#### Принцип работы

1. Вы указываете два коммита:
   - **Хороший (good)** — коммит, в котором баг отсутствует.
   - **Плохой (bad)** — коммит, в котором баг уже наблюдается.

2. Git автоматически выбирает коммит примерно посередине между этими двумя точками и переключается на него.

3. Вы тестируете этот коммит:
   - Если баг есть — отмечаете его как `bad`.
   - Если баг отсутствует — как `good`.

4. Git снова выбирает точку посередине оставшегося диапазона и продолжает этот процесс пока не найдет **первый плохой коммит**, который и ввел баг.

5. После нахождения коммита процесс завершается, и вы можете проанализировать этот конкретный коммит.

#### Основные команды

- `git bisect start` — начало работы с bisect.
- `git bisect bad [<commit>]` — указываете плохой коммит (если не указать, текущий considered bad).
- `git bisect good <commit>` — указываете хороший коммит.
- `git bisect reset` — завершение работы и возврат к изначальному состоянию.

#### Пример использования `git bisect`

Представим, что у вас есть баг в текущем состоянии ветки (`HEAD`), а в одном из старых коммитов бага точно не было.

```bash
# Запускаем bisect-сессию
git bisect start

# Помечаем текущий коммит как плохой, т.к. баг виден здесь
git bisect bad

# Помечаем старый коммит как хороший, там баг не встречался
git bisect good <good-commit-hash>
```

Git перейдет на коммит посередине между этими двумя, и вы должны проверить его. Допустим, баг присутствует, значит:

```bash
git bisect bad
```

Если бага нет, то:

```bash
git bisect good
```

Git снова выберет коммит посредине оставшегося диапазона и переключится на него для проверки. Вы повторяете проверку и маркировку до тех пор, пока Git не укажет:

```
<commit-hash> is the first bad commit
```

После этого желательно завершить bisect:

```bash
git bisect reset
```

#### Автоматизация тестирования через `git bisect run`

Если у вас есть команда или скрипт для автоматического теста проекта (например, сборка и запуск тестов), то можно использовать:

```bash
git bisect start
git bisect bad
git bisect good <good-commit>
git bisect run <тестовая команда или скрипт>
```

Git автоматически будет запускать тест на каждом коммите, помечая его как хороший или плохой в зависимости от результата. Это ускоряет процесс и минимизирует ручную работу.

#### Итоги

- `git bisect` оптимизирует поиск проблемного коммита с помощью бинарного поиска.
- Позволяет находить баги или регрессии быстро даже в длинной истории.
- Поддерживает ручной и автоматический режим тестирования.
- После завершения bisect вы получаете точный коммит, который впервые вызвал проблему.

### git blame


**git blame** — команда Git для показа, кто и когда последний раз изменял каждую строку выбранного файла. В выводе для каждой строки отображаются:

- **SHA-1 хэш коммита**
- **Автор**
- **Дата и время изменения**
- **Собственно строка кода**

Это основной инструмент для исследований истории кода: позволяет быстро выяснить, кто ответственен за конкретные изменения — например, чтобы задать вопросы о найденном баге или понять причину правок

Основной синтаксис:
```bash
git blame <имя_файла>
```
Популярные опции:

- `-L <start>,<end>` — аннотация только определенного диапазона строк
- `-e` — отображение email вместо имени автора
- `-C` и `-M` — отслеживание перемещенных или скопированных строк между файлами для более точной истории
- `-w` — игнорировать изменения только в пробелах

`git blame` помогает ориентироваться в коде совместимых проектов, позволяет выявлять причину ошибок и отслеживать историю появления строк даже после рефакторинга или форматирования кода

**Пример вывода**:
```
301b7eca (ivanov   2023-04-01 14:12:41 +0300 10) print('Hello, world!')
```
Здесь указаны хэш коммита, автор с датой и изменённая строка


### Pickaxe

**Pickaxe** — это внутренняя функция в Git, реализованная с помощью опций команд, таких как **-S** и **-G**, обычно используемых в командах `git log`, `git diff`, `git show` для поиска изменений определённого текста в истории коммитов.

- Опция **-S<строка>** ищет коммиты, в которых количество вхождений заданной строки изменилось (то есть строка была добавлена или удалена) — подходит для поиска, когда и где появился или исчез кусок кода
- Опция **-G<регулярное-выражение>** находит коммиты, где в патче добавились или удалились строки, соответствующие данному регулярному выражению

Флаг `--pickaxe-regex` используется вместе с **-S** для того, чтобы строка воспринималась как регулярное выражение.

**Пример поиска появления/удаления строки:**
```bash
git log -S"some_function" --oneline
```
Этот запрос покажет коммиты, в которых была добавлена или удалена строка, содержащая "some_function".

Pickaxe помогает разработчикам "раскопать" историю изменений определённого участка кода, особенно эффективно работает для анализа появления или исчезновения ключевых фрагментов


## Ветки Git

Ветка git это фундаментальное понятие — отделение разработки в отдельную линию которая не будет затрагивать основную main(master).

### Причины использования веток

- Отдельные версии программ
- Ветка может представлять этап разработки
- Изолировать разработку, для внесения новых функций, тестирования, исправления ошибок
- Отдельная ветка может преставлять отдельного программиста

### Branch vs. tag

Ветка перемещается вместе с коммитами. Имя ветки всегда указывает на последний коммит ветки.

 Тег статическое имя определенного коммита. Он никак не изменяется при добавлении новых изменений.

В репозитории git  могут находиться и тег и ветка с одинаковыми именами. При обращении к такомумимени, git переколчит на ветку и выведет сообщение о неоднозначности в репозитории. Для переключение на тег или ветку в этом случае следует использовать:

```bash
git checkout refs/tags/<name>
git checkout refs/heads/<name>
```

## Имена веток

Ветка может имет любое имя, но с рядом ограничений:

В репозитории всегда есть главная ветка: main или master. Она может быть переименована при необходимости.

Правила:

Имя не может содержать:

- ```..``` две последовательные точки
- пробел или пробельный символ
- спецсимволы git: ```~ ^ : ? * [ ```
- управляющие символы ASCII  
- ```-``` знак минус первым символом
- Знак ```/``` последним символом

### Иерархические имена

Такие имена содержат слэш ```/``` это позволяет объеденять ветки в пространство имен.

Например ветки c префиксом bug, будут означать, что в этих ветках устранаяют и тестируют баги.
Ветка с префиксом dev означает что там ведется разработка и т.д.

Например:

```bash
git branch "bug/strange-things"
git branch "bug/something"
```

 По мимо разделения пространства имен, такие ветки улучшают навигацию по репозиторию.

Например можно вывести информацию о всех ветках с префиксои bug:

```git show-branch bug/*```


##  Работа с ветками


В репозитории может быть множество веток, но только одна ветка активна. 

Коммиты добавляются в активную ветку. Имя ветки указывает на последний коммит(HEAD) в ней. 

Репозиторий git не хранит информацию о том где началась ветка. Новые фиксации создаются на новой ветке. Но благодоря DAG, можно найти коммит алгоритмически от которого произоша новая ветка. В git это делает команда: 

```git merge-base main new-branch```

Имена веток и содержимое коммитов локально для репозитория. 

Можно пересылать в удаленный репозиторий одну или несколько веток. Публикация ветки должна быть явной.


### Создание веток


- Ветка создается на существующей фиксации.
- Можно создать множество веток от одной фиксации
- Ветка может "жить" любое время

Для создания веток используется команда ```git branch```. Без аргментов дання команда выводит список веток.

Для создания ветки от HEAD используется:
```git brach <name-branch>```

Можно указать конкретный коммит:

```git branch new-branch HEAD~```
Или, напрмпер:

```git branch new-branch 45ffed```

Можно указать тег вместл хэша.

Данная команда только добавляет ветку в репозиторий, не производит никаких изменений над файлами, не создает коммитов. Для работы с веткой, необходимо переключение на нее. 
 

### Просмотр веток.


Можно использовать ```git branch```, будет выведен список веток . Активная ветка будет помечена звездочкой.

Для более подробного вывода информации о ветках, используется команда ```git show-branch```

```
! [gh-pages] Deployed e84bf73 with MkDocs version: 1.6.1
 * [main] Branches
--
+  [gh-pages] Deployed e84bf73 with MkDocs version: 1.6.1
+  [gh-pages^] Deployed 17f0112 with MkDocs version: 1.6.1
   .
   .
   .
 * [main] Branches
 * [main^] Fixed typo
   .
   .
   .
 
```

Вывод команды разделен на две секции. В первой секции выводятся все ветки, в произвольном порядке перед именем ветки находится ```!```, который говорит, что эта ветка не активная. ```*``` говорит о том что ветка активная.

Во второй секции выводятся коммиты по умолчанию до первого коммта в репозитории от которого начинается ветка(ветки).

Слева рспологаются символы:

- ```+``` - коммит есть в ветке, помечен цветом ветки 
- ```-``` - произошло слияние
- ```*``` - коммит есть в актиной ветке

В первой секции ветки сдвинуты таким образом, что образуют колонки в секции комиттоа. Колонка относится к одной ветке. Например если в репозитории будеь 5 веток и коммит принадлежит всем веткам, то в колонках будт 4 плюса и одна звездочка.

Знак ```-``` будет относиться только к веткам участвоавшим в слиянии.
 

### Переключение веток


Для переключения веток используется команда ``` git checkout <branch>```.

При использовании команды, будет обнвлена структура файлов и каталогов 
по следующим правилам:

- Файлы и каталоги существующие в ветке на которую проислджит переключение
будут помощены в рабочее дерево файловой структуры.

- Файлы и каталоги существующие в текщей ветке, 
но отсувующие в ветке на которое происходит переключение, будут удалены из рабочева дерева файловой структуры.

- Файлы имеющиеся в обоих ветках будут изменены в соотвесвии с изменнеиям
в той ветке на которое происходит переключение.

Git пердотвращает случаное удаление или модификацию данных без явного запроса.
Неотслеживаемые файлы икаталоги не будет изменяться или перемещать при переключении веток.

Не если есть локальные изменения в файле, которые отличаются от изменений в новой ветке,
git выведет сообщение об ошибке и не переключит ветку:


```bash
git checkot gh-pages
error: Ваши локальные изменения в указанных файлах будут перезаписаны при переключении на состояние:
	docs/git.md
Сделайте коммит или спрячьте ваши изменения перед переключением веток.
Прерываю

```

Применив опицию ``` -f ``` git переключит ветки и тогда изменения в отслеживаемых файлах будут потеряны.

Правильный путь использвать commit или git stash.

``` git checkout -m <branch>``` сольет изменения в ту ветку на которую будет происходить переключение. 
При этом нужно осмотреть репозиторий на наличие мердж конфликтов, при такой комманде git может слить файлы 
индетфтикаторами конфликтов не предупредив о наличи конфликта.

``` git checkot -b <new-branch> <commit>``` создает новую ветку и переключается на нее 
То же действие можно сделать двумя командами;
```bash
git branch <new-branch> <commit>
git checkot <new-branch>
```


### Отсоденение HEAD


С помощью checkout можно переключаться не только на ветки, но и на конкретный коммит.
В таком случае создается анонаимная ветка состящая их одного коммита с остсоедееным(detach) HEAD.
Detach HEAD создается в следующих случаях:

- Переключение на коммит который не является головой любой ветки
- Переключение на ослеживаемую ветку(для исследования недаво внесенных изменений в локальный репозиторий из удаленного)(не понятно!!!)
- Переключение на коммит по ссылке
- Выполенние операции git bisect 
- Использование git submodule update 

Для сохранения изменений в detach HEAD, необходимо будет создать новую ветку и сделать коммит.

Для отката изменений на detach HEAD достаточно переключится на нужную ветку.


### Удаление веток

```git brunch -d <ветка>```

Нельзя удалить текущкю ветку. 

Нельзя удалить ветку, которая содержит коммиты отсутвующие в других ветках.

Для ее удаления сначала нужно слить изменения с любой другой веткой.

Указав -D можно удалить ветку в которой находятся коммиты отсутвующие в других ветках.


## Различия в Git(diff)

diff - программа сравнивающая два текстовых файла построчно, которая выводит отличия между фалйами в специльном виде.

```bash
--- test1.txt   2026-02-05 22:54:52.482529612 +0500
+++ test2.txt   2026-02-05 22:55:40.363810750 +0500
@@ -5,6 +5,7 @@
 Simple is better than complex.
 Complex is better than complicated.
 Flat is better than nested.
+
 Sparse is better than dense.
 Readability counts.
 Special cases aren't special enough to break the rules.
```

```---``` обозначается исходный файл 
```+++``` обозначается изменный файл 

```+``` - Означает что в исходдный файл нужно добавить такую строку, до нового состояния

```-``` - означает что нужно удалиь такую строку, чтобы получить состояние нового файла.
 
### Git diff

Git имеет свою версию diff, которая имеет нюансы и особенности.

``` git diff``` может быть использан со следующими источниками:
- Любой объект дерева(коммит, ветка, ссылка, тег и т.д.)
- Рабочий каталог
- Индекс

1. ```git diff`` -  показывает изменния между индексом и текущим состоянием рабочего каталога(то что станет или может стать коммитом) .  
2. ```git diff <commit>``` - показывает изменения между состояние рабочего каталога и указанного коммита.
3. ```git diff --cached <commit>``` - разница между добавлеными в индекс данными и коммитом. Если коммит не указан, используется HEAD. 
4.  ```git diff <commit1> <commit2>``` - показывает разницу между двумя коммитами.

*Полезные опции*

1.  ```--M``` - изменения в переименовании файлов.
2.  ```-w(--ignore-all-space)``` - сравнение строк без учета пробелов
3.  ```--stat``` - статистика о строка и проч.
4.  ```--color``` - вывод с подсветкой.

#TODO самостоятельно написать пример для git diff, сравнить работу всех вариантов.
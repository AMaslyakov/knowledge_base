# Git 

## Введение

Для любой разработки требуется сохранение кода и контроль версий.
Утилита которая позволяет управлять и отслеживать разными версиями кода называется системой контроля версий.

Рассмотрим программу git, для управления контролем версий. 

## Пакеты git(linux)

Для переноса из других vcs(version control system), могут потребоваться пакеты:
```
git-arch
git-cvs
git-svn
```
Название пакетов в разных дистрибутивах могут отличаться.

Для графического представления истории репозитория могут пригодиться пакеты:
```
git-gui
gitk
gitweb
```
Для отправки патчей посредством email понадобится пакет:

```
git-email
```

## Установка в Windows

Для установки git в Windows. Можно установить:

[https://git-scm.com/download/win](https://git-scm.com/download/win)

Либо Cygwing git:

[https://cygwing.com](https://cygwing.com)


Либо пакет msysGit:

[https://gitforwindows.org/](https://gitforwindows.org/)

## Как хранятся изменения внутри git

Данные репозитория хранятся в директории ```.git```. Git управляет хранилищем объектов и индексом.

Хранилище объектов содержит четыре типа объектов:

- BLOB(Binary Large Object) содержит данные без метаданных
- Деревья. Дерево представляет один уровень, записывает id блобов, имена путей, небольшие метаданные для всех файлов в каталоге
- Коммиты хранят метаданные изменений(имя автора, дату, сообщение коммита) Каждый коммит ссылается на снимок состояния репозитория (объект дерева). Обычные коммиты имеют одного родителя, но возможны и коммиты с несколькими родителями (например, при слиянии веток).  
- Теги человекочитаемое имя назначаемое объекту, обычно коммитам. Например Ver.-1.0

## Индекс

В git это временный и динамический бинарный файл, который описывает структуру каталогов всего репозитория. В частности, индекс получает версию полной структуры проекта в некоторый момент времени.

Git позволяет изменять содержимое индекса четко определенными действиями.

Индекс хранит изменения до коммита.
Изменяется с помощью добавления, удаления, редактирования фпйлов.

## Идентификаторы объектов

Хранилище объектов git организовано в виде ассоциативной системы хранения. Каждому объекту присваивается уникальное имя - идентификатор, на основе алгоритма SHA1. Идентфикатор объекта представляется в виде 40-разрядного 16-ричного числа. Часто его еще называют _хэшкод_.
Хэшкод вычисляется на основе содержимого объекта. Если содержимое объектов идентично они имеют одинаковый хэшкод.

## Отслеживание контента

Благодаря идентификаторам, git может отслеживать контент. Если в репозитории существует два идентичных файла, то для них в хранилище будет создан один BLOB с хэшкодом вычисленным на основе содержимого.

Если один из файлов после изменений будет иметь отличия, соответственно создаться новый BLOB с новым идентификатором объекта.

## Путь vs. Содержание

Git имеет собственную структуру хранилища, которая не основывается на именах и путях файлов. Внутренняя структура git более эффективна для собственных операций над объектами. И она позволяет точно воспроизвести файлы и каталоги проекты проиндексированные хэшем.

## Pack-файлы


Git умно упаковывает файлы. Он находит файлы похожие по содержанию и сохраняет полностью только один файл. Другой файл сохраняется в хранилище в виде дельты, т.е. сохраняется только разница содержимого между первым и вторым файлом.

## Управление индексом

Состояние индекса можно узнать в любой момент с помощью команды:

```git status```

Файлы классифицируются на:

-  отслеживаемые(tracked)
-  игнорируемые(ignored)
-  неотслеживаемые(untracked)

*Отслеживаемые* файлы уже находятся в репозитории

*Игнорируемые* явно объявленные файлы и деректории в .gitignore 

*Неотслеживаемые* файлы которые не добавлены в индекс и отсутствуют в .gitignore


### git add

Добавляет файл(ы) в индекс. Т.е. файл(ы) становится отслеживаемым(и). Также добавляет изменения для уже отслеживаемых файлов.

### git commit

Производится фиксация изменений добавленных в индекс.

Команда ```git commit --all``` автоматически добавляет в индекс изменения отслеживаемых файлов и сразу создает коммит. Не отслеживаемые файлы при этом не меняют свой статус.

Если не указать опцию ```-m``` git запустит редактор указанный в конфигурации для создания коммита.


### git rm

Команда удаляет файлы из индекса и из каталога. Либо удаляет файлы только  из индекса. Не может удалить файлы только с диска(для этого нужно использовать системную команду), т.е. команда работает только с файлами добавленными в репозиторий.

Команда:

```git rm --cached```

Удаляет файл из индекса. Т.е. делает файл неотслеживаемым. 

Но команда ```git rm ``` удалит файл и из индекса и с диска до коммита и после коммита.

Команда:

```git rm -f``` 

Удалит даже отслеживаемый модифицированный файл не добавленный в индекс.

Для восстановления файла удаленного командой ```git rm``` можно использовать механизм восстановления файлов:

```git checkout HEAD -- <file>```

### git mv


Позволяет перемещать и переименовывать файлы находящиеся репозитории или в индексе.

Синтаксис:

```git mv  <file1> <file2>```

## .gitignore

Содержит список файлов и шаблонов которые нужно игнорировать. 


### Формат .gitignore

```# Files``` -- комментарий

```\#file.txt``` -- если название файла начинается с решетки

```file.txt``` -- имена файлов полном виде

```dir/``` -- каталог отмечается следующим образом

```*``` -- заменяет любые символы

Например:

```*.txt``` -- игнорировать все файлы с расширением ```.txt```

```!``` -- задает исключение для общего правила заданного с помощью предшествующего правила.

Например:

```
logs/
!logs/log.txt
```

Игнорирует папку logs и все содержимое, но отслеживает logs/log.txt

```
*.txt
!history.txt
```

Игнорирует все файлы txt, но отслеживает history.txt

Файлы .gitignore можно создавать в любом каталоге репозитория. Каждый файл влияет только на свой каталог и все подкаталоги. Правила .gitignore каскадные, определив общее правило в каталоге высокого уровня, его можно отменять с помощью ```!``` в подкаталогах.

### Приоритет игнорирования

- Шаблоны определенные в командной строке ???
- Шаблоны из файла в верхнем каталоге
- Шаблоны в родительских каталогах, они будут перезаписаны с помощью .gitignore более высокого уровня
- Шаблоны из файла ```.git/info/exclude```
- Шаблоны из файла указанного переменной конфигурации ```core.excludefile```  

*exclude* -- содержит шаблоны как и в .gitignore. Позволяет игнорировать специфичные файлы характерные для операционной системы или ПО, но в .gitignore репозитория отмечать файлы характерные только для его специфики.

## Коммиты(фиксации)

Коммит это добавление изменений в репозитрий. Git сравнивает ткущее состояние индекса с предыдущим и получает список добавленых/измененых/удаленных файлов
/каталогов. Если файл/каталог изменился создается новый BLOB, если не изменился используются имеющиеся блобы.

Коммиты объденяются в цепочку, в которой каждый новый коммит указывает на превдшественика.

Коммит это единственный способ представления изменений в репозиторий.

Git нормально относится к частым коммитам и обеспечивает богатый набор комманд для управления ими.

### Атомарные наборы изменений

Разработчик отправляющий изменения в репозиторий должен стремится чтобы каждый коммит представлял собой атомарный(неделимый) набор изменений не зависимо от количества созданых/модифицированных/удаленных файлов/каталогов. 


Пример на Python, иллюстрирующий разницу между неатомарным и атомарным переносом функции между файлами:

### Исходное состояние

**file_a.py**
```python
def foo():
    print("foo из file_a")

def bar():
    print("bar из file_a")
```

**file_b.py**
```python
def baz():
    print("baz из file_b")
```

**main.py**
```python
from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
```

## Пример 1: Неатомарный перенос (код не работает)

**Шаг 1.** Удаляем функцию `foo` из `file_a.py` (делаем коммит).

**file_a.py**
```python
def bar():
    print("bar из file_a")
```

**file_b.py** (без изменений)
```python
def baz():
    print("baz из file_b")
```

**main.py** (без изменений)
```python
from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
```

**Результат:**  
При запуске `main.py` возникает ошибка:
> ImportError: cannot import name 'foo' from 'file_a'

**Причина:**  
Функция удалена, но импорт в main.py не изменён. Код не работает.

## Пример 2: Атомарный перенос (код работает)

**Шаг 1.** Переносим функцию `foo` в `file_b.py` и корректируем все импорты (делаем один атомарный коммит).

**file_a.py**
```python
def bar():
    print("bar из file_a")
```

**file_b.py**
```python
def baz():
    print("baz из file_b")

def foo():
    print("foo из file_b")
```

**main.py**
```python
from file_a import bar
from file_b import baz, foo

foo()
bar()
baz()
```

**Результат:**  
Код запускается без ошибок, все функции доступны и работают как ожидается.

**Вывод:**  
В первом случае коммит неатомарный — функция удалена, но не добавлена в новый файл и не исправлены импорты, из-за чего код ломается.  
Во втором случае коммит атомарный — все изменения внесены одновременно, код всегда находится в рабочем состоянии. 

Git все равно как сделан коммит, но если не учитывать атомарность фиксаций, репозиторий будет иметь переходные состояния.

## Идентификация фиксаций.

Как и любой объект в git коммит имеет идентификатор - хэш-код.

Идентификаторы нужны для создания веток, для сравнения двух веток, для 
изменения истории коммитов


### Абсолютные имена фиксации

Хэш-код коммита -- это абсолютное имя которое относится только к одному коммиту. Такой идентификатор *глобален*. Если есть два коммитс с одинаковым именем в двух разных репозиториях, это значит что их содержимое одинаково.

Для удобства 40-значное абсолютное имя коммита сокращается до 6 знаков при использовании коммандами Git. 

```
git log -1 --pretty=oneline HEAD
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
```

```
git log -1 --pretty=oneline 3e7d33
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
```

### Ссылки и символьные ссылки

Хэшкод является ссылкой относящейся к объекту.

Символическая ссылка это имя коссвенно указывающее на объект.

Локальные имена ветки, удаленные имена ветки, имена тэгов -- все это ссылки.

У символической ссылки есть явное - полное имя, которое хранится в каталоге .git/refs/

Обычно представлено три пространства имен:
- refs/heads/refs - локальные ветки
- refs/remotes/ref - удаленные ветки 
- refs/tag/ref - теги

Например для локальной ветки dev, будет соотвеовать ссылка:
    
    refs/heads/dev

Для удаленой ветки origin/master, соответсовать:

    refs/remotes/origin/master

Для тега v2.6.23, будет соотвествовать ссылка:

    refs/tags/v2.6.23

Если тег и ветка будут иметь одинаковые имена, то порядок поиска ссылок будет проходить как:

-    .git/ref(Для специальных ссылок HEAD, ORIG_HEAD...)
-    .git/refs/ref
-    .git/refs/tags/ref
-    .git/refs/heads/ref
-    .git/refs/remotes/ref
-    .git/refs/remotes/ref/HEAD


### Специальные символьные ссылки 

**HEAD** указывает на самую последнюю фиксацию в текущей ветке. 
За исключением ситуации, detach HEAD, при переключении на какой-либо коммит. Detach HEAD будет указывать на переключенный коммит. detach -- говорит о том, что HEAD не прикреплен к конкретной ветке.

**ORIG_HEAD** такие операции как merge revert записывают предыдущию версию HEAD в ORIG_HEAD. Данную ссылку можно использовать для восстановления предыдущего состяния или сравнения.

**FETCH_HEAD** сюда команда ```git fetch``` записывает головы всех удаленных веток. Ссылка доступна после опреции fetch

**MERGE_HEAD** указывает на вершину ветки с которой было сделано слияние. Ссылка доступна после слияния.

Все символические ссылки управляются командой ```git symbolic-ref``` 

### Относительные имена фиксаций

Для быстрого выполнения команд и навигации между комиттами git предлагает механизм относительных имен. С помощью символово ```~``` и ```^```.

Совместно с этими символами можно использовать символьные ссылки ```HEAD```, имена веток, сокращенный хэшкод.

Предыдущий коммит в main:

```main^``` или ```main~``` или ```main~1```

Предыдущий от предидущего:

```main^^``` или ```main~2```


При слиянии у коммттов могут образовываться родители 2 и болле. ```^``` используется для навигации по родителям коммта. 
Первый родитель коммита:

```main^``` или ```main^1```

Второй родитель коммита:

```main^2``` 

Данные обозначения можно комбинировать. Например:

```main~9^2~3^4```

Используя:

```git show-branch --more=10```

Можно изучать структуру графа репозитория и иследовать слодные слияния. 

## История фиксаций

### Просмотр коммитов

Основная команда для просмотра коммитов:

```git log```

Запись без параметров аналгоична комманде:

```git log HEAD```

Выводит исторю коммитов в обратном хронологическом порядке, от коммита HEAD. Но нужно помниить, что при перемещении по истории ккоммитов git придерживается их графика, а не времени.


Вывод ```git log``` можно менять с помощью аргумента ```--pretty```. Можно выбрать формат вывода из готовых вартантов (full, short, oneline). Или задать формат с помощью значения format.

Примеры:

```git log --pretty=short main```

```
commit f068b66b1332771771ddc0cbdf55da2ac4c4add5
Author: AMaslyakov <A.V.Masliakov@urfu.me>

    Relative names
```

```git log --pretty=format:"Хэш: %H сокращенный хэш:%h"```

```Хэш: f068b66b1332771771ddc0cbdf55da2ac4c4add5, сокращелнный хэш: f068b66```

Можно ограничить вывод истории между несколькими коммитами:

```git log --pretty=short  main~12..main~10```

Покажет историю между 10-м и 11-м коммитом в main в формате 
short.

Комманда:

```git log -1 -p 4а3688```

Выведет изменения созданные в коммите

Атрибут ```--stat``` добавит иноформацию о количестве измененных файлов и количестве добавленных и удаленных строк.

Коммандой:

```git show <commit>```

можно просматривать конкретные коммиты.

## Графы коммитов

Коммиты внутри git связываются в один большой граф. Данный граф называется DAG графом(direct acyclic graph, направленый ациклический граф). В таком графе коммиты являются вершинами, которые имеют однонаправленую связь в виде ребра, от последнего коммита к предыдущему(предыдущим если 2 и более родителей).

DAG имеет два важных свойства:

1. Ребра однонаправлены

1. Если начать обход по ребрам с любой вершины, то обратного пути для возвращения в исходную вершину не существует.

На истори коммитов ниже, время идет слева на право. Но для гит не имеет значение когда были сделаны коммиты E и C. Коммиты могли быть сделаны в разных часовых поясах. 
Ветка master состоит из коммитов: A, B, C, D, H.
Ветка pr17  состоит из коммитов  A, B, E, F, G.

После слияния веток master будет указывать на коммит H, а pr17 так и будет указывать на G, как было до слияния.

```
         E<--F<--G 
        /         \
A <-- B<--C<--D<--H 

G - pr17 branch
H - master

```

### Понимание DAG коммитов

- У каждого коммита может быть 0 и более родителей

- У обычных коммитов есть только один родитель

- У начальной фиксации(коммита) нет родителей, т.е. их 0

- У merge коммита болле одного родителя

- Коммит у которого два и более  потомка(ребенка/children) формирует ветку. Для примера выше это коммит B


### Диапазонны фиксаций

Для изучения ветки или части ветки, в гит можно использовать диапазоны коммитов. Рассмотрим пример для ветки M.

 ```M~14<-M~13<-M~12<-M~11-M~10<-M~9```

Где ```M~14``` самый старый коммит на даннм отрезке ветки, а ```M~9``` самый новый на данном отрезке

Диапазон коммитов обозначается как ```<start>..<end>``` например:

```M~12..M~10``` -- что соответствует двум коммитам ```M~10, M~11```. ```M~12```не включен в диапазон. Так устроенно из-за определения диапазона коммитов в git -- это набор коммитов достижимых с конца(end), но не достижимых с начала(start). Другими словами end, включен в диапазон, а start не включен. 
Математически:

<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo>(</mo>
  <mi>start</mi>
  <mo>;</mo>
  <mi>end</mi>
  <mo>]</mo>
</math>


При этом напрвление start end соотвесьвуют хронологическому порядку. Start старше, чем end. Но при этом не включение start в диапазон, обозначает направление связей от end в сторону старших коммитов.

## Достижимость в графах

Коммит X достижим из коммита Y, когда можно пойти из коммита Y по дугам графа, по направления ребер и прийти в коммит X.

Достижимость коммитов используется например для комманды ```git log```.

Пусть имеется репозиторй с двумя ветками: mian и branch. Произведено слияние из branch в main.Тогда:

```
            D(branch)  
           /   \    
A <- B <- C <-  E <- F(main)
```

Команда ```git log main``` выведет исторю для всех достижимых узлов: F, E, D, C, B, A. 

Команда ```git log branch```выведет историю для достижимых узлов: D, C, B, A.


Пусть имеется репозиторй с двумя ветками: mian и branch. Но слияние произведено из main в branch.Тогда:

```
            D <- G(branch)  
           /     /  
A <- B <- C <-  E <- F(main)
```

Команда ```git log main``` покажет историю из: F, E, C, B, A. Коммиты D, G будут не достижимы из F.

Команда ```git log branch``` покажет историю из: G, E, D, C, B, A. Из G будет не достижим только коммит F.

### Исключение коммитов и веток

Для того чтобы исключить коммит и все достижимые из него узлы используется префикс ```^```(в отличие от постфикса, указание на родителя).

Например для ветки:

```A <- B <- C <- main```

```git log ^B main```

Будет выведено: main, C.

При этом порядок не важен:
                              │  ```git log  main ^B```

Данная команда эквивалентна команде:

```git log B..main```

Рассмотрим диапазон конкретнее на других примерах.


```
      <-G<-D(branch)
           /(merge to branch)   
A <- B <- C <-  E <- F(main)

```

Команда ```git log branch..main``` выведет: F(main), E.
Все узлы достижимые из branch, включая узел C в котором ветка branch была создана, будут исключены. 

Для случая:
```
    W<-X<-Y <-Z (branch)
      /        \
A <- B <- C <-  D(main)

```

Команда ```git log branch..main``` выведет: D(main), C. Потомучто все узлы достижимые из branch будут исключены, в том числе и Z(branch)

Диапазон можно задавать в коротком варианте: ```start..```, ```..end```. Что эквивалентно ```start..HEAD```, ```HEAD..end``` соотвественно.

Так же запись диапазонна можно рассматривать как разницу:

```A <- B <- C <- main```

```git log B..main```

```A - B
          C - main 
```

### Симметричный диапазон(симметричная разница)

Получается с помощью символа ```a...b``` - троеточие. Выводит те узлы которые доступны только  из start или доступны только из end, но не одновременно. При этом узлы a, b не являбтся ни концом ни началом. Поэтому  ```b...a``` будет эквивалентно ```a...b```

```
A <- B <- C <- D<- E <-F<-G(main)
              \      /
               U <- V <-X <-Y(dev)
```

Из main достижимы:
(G), (F), V, U, C, (E), (D), B, A
Из dev достижимы|
(Y), (X), V, U, C, B, A.

в скобках помечены коммиты, которых нет в другой ветке.

Соответсвенно команда ```git log dev...main```, выведет коммииты: D, E, F, X, Y, G

## Поиск коммитов

### git bisect


`git bisect` — это инструмент Git для **поиска коммита, в котором впервые появился баг или регрессия**. Он использует **бинарный поиск** по истории коммитов, что позволяет значительно сократить время поиска проблемного изменения.

#### Принцип работы

1. Вы указываете два коммита:
   - **Хороший (good)** — коммит, в котором баг отсутствует.
   - **Плохой (bad)** — коммит, в котором баг уже наблюдается.

2. Git автоматически выбирает коммит примерно посередине между этими двумя точками и переключается на него.

3. Вы тестируете этот коммит:
   - Если баг есть — отмечаете его как `bad`.
   - Если баг отсутствует — как `good`.

4. Git снова выбирает точку посередине оставшегося диапазона и продолжает этот процесс пока не найдет **первый плохой коммит**, который и ввел баг.

5. После нахождения коммита процесс завершается, и вы можете проанализировать этот конкретный коммит.

#### Основные команды

- `git bisect start` — начало работы с bisect.
- `git bisect bad [<commit>]` — указываете плохой коммит (если не указать, текущий considered bad).
- `git bisect good <commit>` — указываете хороший коммит.
- `git bisect reset` — завершение работы и возврат к изначальному состоянию.

#### Пример использования `git bisect`

Представим, что у вас есть баг в текущем состоянии ветки (`HEAD`), а в одном из старых коммитов бага точно не было.

```bash
# Запускаем bisect-сессию
git bisect start

# Помечаем текущий коммит как плохой, т.к. баг виден здесь
git bisect bad

# Помечаем старый коммит как хороший, там баг не встречался
git bisect good <good-commit-hash>
```

Git перейдет на коммит посередине между этими двумя, и вы должны проверить его. Допустим, баг присутствует, значит:

```bash
git bisect bad
```

Если бага нет, то:

```bash
git bisect good
```

Git снова выберет коммит посредине оставшегося диапазона и переключится на него для проверки. Вы повторяете проверку и маркировку до тех пор, пока Git не укажет:

```
<commit-hash> is the first bad commit
```

После этого желательно завершить bisect:

```bash
git bisect reset
```

#### Автоматизация тестирования через `git bisect run`

Если у вас есть команда или скрипт для автоматического теста проекта (например, сборка и запуск тестов), то можно использовать:

```bash
git bisect start
git bisect bad
git bisect good <good-commit>
git bisect run <тестовая команда или скрипт>
```

Git автоматически будет запускать тест на каждом коммите, помечая его как хороший или плохой в зависимости от результата. Это ускоряет процесс и минимизирует ручную работу.

#### Итоги

- `git bisect` оптимизирует поиск проблемного коммита с помощью бинарного поиска.
- Позволяет находить баги или регрессии быстро даже в длинной истории.
- Поддерживает ручной и автоматический режим тестирования.
- После завершения bisect вы получаете точный коммит, который впервые вызвал проблему.

### git blame


**git blame** — команда Git для показа, кто и когда последний раз изменял каждую строку выбранного файла. В выводе для каждой строки отображаются:

- **SHA-1 хэш коммита**
- **Автор**
- **Дата и время изменения**
- **Собственно строка кода**

Это основной инструмент для исследований истории кода: позволяет быстро выяснить, кто ответственен за конкретные изменения — например, чтобы задать вопросы о найденном баге или понять причину правок

Основной синтаксис:
```bash
git blame <имя_файла>
```
Популярные опции:

- `-L <start>,<end>` — аннотация только определенного диапазона строк
- `-e` — отображение email вместо имени автора
- `-C` и `-M` — отслеживание перемещенных или скопированных строк между файлами для более точной истории
- `-w` — игнорировать изменения только в пробелах

`git blame` помогает ориентироваться в коде совместимых проектов, позволяет выявлять причину ошибок и отслеживать историю появления строк даже после рефакторинга или форматирования кода

**Пример вывода**:
```
301b7eca (ivanov   2023-04-01 14:12:41 +0300 10) print('Hello, world!')
```
Здесь указаны хэш коммита, автор с датой и изменённая строка


### Pickaxe

**Pickaxe** — это внутренняя функция в Git, реализованная с помощью опций команд, таких как **-S** и **-G**, обычно используемых в командах `git log`, `git diff`, `git show` для поиска изменений определённого текста в истории коммитов.

- Опция **-S<строка>** ищет коммиты, в которых количество вхождений заданной строки изменилось (то есть строка была добавлена или удалена) — подходит для поиска, когда и где появился или исчез кусок кода
- Опция **-G<регулярное-выражение>** находит коммиты, где в патче добавились или удалились строки, соответствующие данному регулярному выражению

Флаг `--pickaxe-regex` используется вместе с **-S** для того, чтобы строка воспринималась как регулярное выражение.

**Пример поиска появления/удаления строки:**
```bash
git log -S"some_function" --oneline
```
Этот запрос покажет коммиты, в которых была добавлена или удалена строка, содержащая "some_function".

Pickaxe помогает разработчикам "раскопать" историю изменений определённого участка кода, особенно эффективно работает для анализа появления или исчезновения ключевых фрагментов


# Ветки Git



# Git 

## Введение

Для любой разработки требуется сохранение кода и контроль версий.
Утилита которая позволяет управлять и отслеживать разными версиями кода называется системой контроля версий.

Рассмотрим программу git, для управления контролем версий. 

## Пакеты git(linux)

Для переноса из других vcs(version control system), могут потребоваться пакеты:
```
git-arch
git-cvs
git-svn
```
Название пакетов в разных дистрибутивах могут отличаться.

Для графического представления истории репозитория могут пригодиться пакеты:
```
git-gui
gitk
gitweb
```
Для отправки патчей посредством email понадобится пакет:

```
git-email
```

## Установка в Windows

Для установки git в Windows. Можно установить:

[https://git-scm.com/download/win](https://git-scm.com/download/win)

Либо Cygwing git:

[https://cygwing.com](https://cygwing.com)


Либо пакет msysGit:

[https://gitforwindows.org/](https://gitforwindows.org/)

## Как хранятся изменения внутри git

Данные репозитория хранятся в директории ```.git```. Git управляет хранилищем объектов и индексом.

Хранилище объектов содержит четыре типа объектов:

- BLOB(Binary Large Object) содержит данные без метаданных
- Деревья. Дерево представляет один уровень, записывает id блобов, имена путей, небольшие метаданные для всех файлов в каталоге
- Коммиты хранят метаданные изменений(имя автора, дату, сообщение коммита) Каждый коммит ссылается на снимок состояния репозитория (объект дерева). Обычные коммиты имеют одного родителя, но возможны и коммиты с несколькими родителями (например, при слиянии веток).  
- Теги человекочитаемое имя назначаемое объекту, обычно коммитам. Например Ver.-1.0

## Индекс

В git это временный и динамический бинарный файл, который описывает структуру каталогов всего репозитория. В частности, индекс получает версию полной структуры проекта в некоторый момент времени.

Git позволяет изменять содержимое индекса четко определенными действиями.

Индекс хранит изменения до коммита.
Изменяется с помощью добавления, удаления, редактирования фпйлов.

## Идентификаторы объектов

Хранилище объектов git организовано в виде ассоциативной системы хранения. Каждому объекту присваивается уникальное имя - идентификатор, на основе алгоритма SHA1. Идентфикатор объекта представляется в виде 40-разрядного 16-ричного числа. Часто его еще называют _хэшкод_.
Хэшкод вычисляется на основе содержимого объекта. Если содержимое объектов идентично они имеют одинаковый хэшкод.

## Отслеживание контента

Благодаря идентификаторам, git может отслеживать контент. Если в репозитории существует два идентичных файла, то для них в хранилище будет создан один BLOB с хэшкодом вычисленным на основе содержимого.

Если один из файлов после изменений будет иметь отличия, соответственно создаться новый BLOB с новым идентификатором объекта.

## Путь vs. Содержание

Git имеет собственную структуру хранилища, которая не основывается на именах и путях файлов. Внутренняя структура git более эффективна для собственных операций над объектами. И она позволяет точно воспроизвести файлы и каталоги проекты проиндексированные хэшем.

## Pack-файлы


Git умно упаковывает файлы. Он находит файлы похожие по содержанию и сохраняет полностью только один файл. Другой файл сохраняется в хранилище в виде дельты, т.е. сохраняется только разница содержимого между первым и вторым файлом.

## Управление индексом

Состояние индекса можно узнать в любой момент с помощью команды:

```git status```

Файлы классифицируются на:

-  отслеживаемые(tracked)
-  игнорируемые(ignored)
-  неотслеживаемые(untracked)

*Отслеживаемые* файлы уже находятся в репозитории

*Игнорируемые* явно объявленные файлы и деректории в .gitignore 

*Неотслеживаемые* файлы которые не добавлены в индекс и отсутствуют в .gitignore


### git add

Добавляет файл(ы) в индекс. Т.е. файл(ы) становится отслеживаемым(и). Также добавляет изменения для уже отслеживаемых файлов.

### git commit

Производится фиксация изменений добавленных в индекс.

Команда ```git commit --all``` автоматически добавляет в индекс изменения отслеживаемых файлов и сразу создает коммит. Не отслеживаемые файлы при этом не меняют свой статус.

Если не указать опцию ```-m``` git запустит редактор указанный в конфигурации для создания коммита.


### git rm

Команда удаляет файлы из индекса и из каталога. Либо удаляет файлы только  из индекса. Не может удалить файлы только с диска(для этого нужно использовать системную команду), т.е. команда работает только с файлами добавленными в репозиторий.

Команда:

```git rm --cached```

Удаляет файл из индекса. Т.е. делает файл неотслеживаемым. 

Но команда ```git rm ``` удалит файл и из индекса и с диска до коммита и после коммита.

Команда:

```git rm -f``` 

Удалит даже отслеживаемый модифицированный файл не добавленный в индекс.

Для восстановления файла удаленного командой ```git rm``` можно использовать механизм восстановления файлов:

```git checkout HEAD -- <file>```

### git mv


Позволяет перемещать и переименовывать файлы находящиеся репозитории или в индексе.

Синтаксис:

```git mv  <file1> <file2>```

## .gitignore

Содержит список файлов и шаблонов которые нужно игнорировать. 


### Формат .gitignore

```# Files``` -- комментарий

```\#file.txt``` -- если название файла начинается с решетки

```file.txt``` -- имена файлов полном виде

```dir/``` -- каталог отмечается следующим образом

```*``` -- заменяет любые символы

Например:

```*.txt``` -- игнорировать все файлы с расширением ```.txt```

```!``` -- задает исключение для общего правила заданного с помощью предшествующего правила.

Например:

```
logs/
!logs/log.txt
```

Игнорирует папку logs и все содержимое, но отслеживает logs/log.txt

```
*.txt
!history.txt
```

Игнорирует все файлы txt, но отслеживает history.txt

Файлы .gitignore можно создавать в любом каталоге репозитория. Каждый файл влияет только на свой каталог и все подкаталоги. Правила .gitignore каскадные, определив общее правило в каталоге высокого уровня, его можно отменять с помощью ```!``` в подкаталогах.

### Приоритет игнорирования

- Шаблоны определенные в командной строке ???
- Шаблоны из файла в верхнем каталоге
- Шаблоны в родительских каталогах, они будут перезаписаны с помощью .gitignore более высокого уровня
- Шаблоны из файла ```.git/info/exclude```
- Шаблоны из файла указанного переменной конфигурации ```core.excludefile```  

*exclude* -- содержит шаблоны как и в .gitignore. Позволяет игнорировать специфичные файлы характерные для операционной системы или ПО, но в .gitignore репозитория отмечать файлы характерные только для его специфики.

## Коммиты(фиксации)

Коммит это добавление изменений в репозитрий. Git сравнивает ткущее состояние индекса с предыдущим и получает список добавленых/измененых/удаленных файлов
/каталогов. Если файл/каталог изменился создается новый BLOB, если не изменился используются имеющиеся блобы.

Коммиты объденяются в цепочку, в которой каждый новый коммит указывает на превдшественика.

Коммит это единственный способ представления изменений в репозиторий.

Git нормально относится к частым коммитам и обеспечивает богатый набор комманд для управления ими.

### Атомарные наборы изменений

Разработчик отправляющий изменения в репозиторий должен стремится чтобы каждый коммит представлял собой атомарный(неделимый) набор изменений не зависимо от количества созданых/модифицированных/удаленных файлов/каталогов. 


Пример на Python, иллюстрирующий разницу между неатомарным и атомарным переносом функции между файлами:

### Исходное состояние

**file_a.py**
```python
def foo():
    print("foo из file_a")

def bar():
    print("bar из file_a")
```

**file_b.py**
```python
def baz():
    print("baz из file_b")
```

**main.py**
```python
from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
```

## Пример 1: Неатомарный перенос (код не работает)

**Шаг 1.** Удаляем функцию `foo` из `file_a.py` (делаем коммит).

**file_a.py**
```python
def bar():
    print("bar из file_a")
```

**file_b.py** (без изменений)
```python
def baz():
    print("baz из file_b")
```

**main.py** (без изменений)
```python
from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
```

**Результат:**  
При запуске `main.py` возникает ошибка:
> ImportError: cannot import name 'foo' from 'file_a'

**Причина:**  
Функция удалена, но импорт в main.py не изменён. Код не работает.

## Пример 2: Атомарный перенос (код работает)

**Шаг 1.** Переносим функцию `foo` в `file_b.py` и корректируем все импорты (делаем один атомарный коммит).

**file_a.py**
```python
def bar():
    print("bar из file_a")
```

**file_b.py**
```python
def baz():
    print("baz из file_b")

def foo():
    print("foo из file_b")
```

**main.py**
```python
from file_a import bar
from file_b import baz, foo

foo()
bar()
baz()
```

**Результат:**  
Код запускается без ошибок, все функции доступны и работают как ожидается.

**Вывод:**  
В первом случае коммит неатомарный — функция удалена, но не добавлена в новый файл и не исправлены импорты, из-за чего код ломается.  
Во втором случае коммит атомарный — все изменения внесены одновременно, код всегда находится в рабочем состоянии. 

Git все равно как сделан коммит, но если не учитывать атомарность фиксаций, репозиторий будет иметь переходные состояния.

## Идентификация фиксаций.

Как и любой объект в git коммит имеет идентификатор - хэш-код.

Идентификаторы нужны для создания веток, для сравнения двух веток, для 
изменения истории коммитов


### Абсолютные имена фиксации

Хэш-код коммита -- это абсолютное имя которое относится только к одному коммиту. Такой идентификатор *глобален*. Если есть два коммитс с одинаковым именем в двух разных репозиториях, это значит что их содержимое одинаково.

Для удобства 40-значное абсолютное имя коммита сокращается до 6 знаков при использовании коммандами Git. 

```
git log -1 --pretty=oneline HEAD
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
```

```
git log -1 --pretty=oneline 3e7d33
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
```

### Ссылки и символьные ссылки

Хэшкод является ссылкой относящейся к объекту.

Символическая ссылка это имя коссвенно указывающее на объект.

Локальные имена ветки, удаленные имена ветки, имена тэгов -- все это ссылки.

У символической ссылки есть явное - полное имя, которое хранится в каталоге .git/refs/

Обычно представлено три пространства имен:
- refs/heads/refs - локальные ветки
- refs/remotes/ref - удаленные ветки 
- refs/tag/ref - теги

Например для локальной ветки dev, будет соотвеовать ссылка:
    
    refs/heads/dev

Для удаленой ветки origin/master, соответсовать:

    refs/remotes/origin/master

Для тега v2.6.23, будет соотвествовать ссылка:

    refs/tags/v2.6.23

Если тег и ветка будут иметь одинаковые имена, то порядок поиска ссылок будет проходить как:

-    .git/ref(Для специальных ссылок HEAD, ORIG_HEAD...)
-    .git/refs/ref
-    .git/refs/tags/ref
-    .git/refs/heads/ref
-    .git/refs/remotes/ref
-    .git/refs/remotes/ref/HEAD


### Специальные символьные ссылки 

**HEAD** указывает на самую последнюю фиксацию в текущей ветке. 
За исключением ситуации, detach HEAD, при переключении на какой-либо коммит. Detach HEAD будет указывать на переключенный коммит. detach -- говорит о том, что HEAD не прикреплен к конкретной ветке.

**ORIG_HEAD** такие операции как merge revert записывают предыдущию версию HEAD в ORIG_HEAD. Данную ссылку можно использовать для восстановления предыдущего состяния или сравнения.

**FETCH_HEAD** сюда команда ```git fetch``` записывает головы всех удаленных веток. Ссылка доступна после опреции fetch

**MERGE_HEAD** указывает на вершину ветки с которой было сделано слияние. Ссылка доступна после слияния.

Все символические ссылки управляются командой ```git symbolic-ref``` 

### Относительные имена фиксаций

Для быстрого выполнения команд и навигации между комиттами git предлагает механизм относительных имен. С помощью символово ```~``` и ```^```.

Совместно с этими символами можно использовать символьные ссылки ```HEAD```, имена веток, сокращенный хэшкод.

Предыдущий коммит в main:

```main^``` или ```main~``` или ```main~1```

Предыдущий от предидущего:

```main^^``` или ```main~2```


При слиянии у коммттов могут образовываться родители 2 и болле. ```^``` используется для навигации по родителям коммта. 
Первый родитель коммита:

```main^``` или ```main^1```

Второй родитель коммита:

```main^2``` 

Данные обозначения можно комбинировать. Например:

```main~9^2~3^4```

Используя:

```git show-branch --more=10```

Можно изучать структуру графа репозитория и иследовать слодные слияния. 

## История фиксаций

### Просмотр коммитов

Основная команда для просмотра коммитов:

```git log```

Запись без параметров аналгоична комманде:

```git log HEAD```

Выводит исторю коммитов в обратном хронологическом порядке, от коммита HEAD. Но нужно помниить, что при перемещении по истории ккоммитов git придерживается их графика, а не времени.


Вывод ```git log``` можно менять с помощью аргумента ```--pretty```. Можно выбрать формат вывода из готовых вартантов (full, short, oneline). Или задать формат с помощью значения format.

Примеры:

```git log --pretty=short main```

```
commit f068b66b1332771771ddc0cbdf55da2ac4c4add5
Author: AMaslyakov <A.V.Masliakov@urfu.me>

    Relative names
```

```git log --pretty=format:"Хэш: %H сокращенный хэш:%h"```

```Хэш: f068b66b1332771771ddc0cbdf55da2ac4c4add5, сокращелнный хэш: f068b66```

Можно ограничить вывод истории между несколькими коммитами:

```git log --pretty=short  main~12..main~10```

Покажет историю между 10-м и 11-м коммитом в main в формате 
short.

Комманда:

```git log -1 -p 4а3688```

Выведет изменения созданные в коммите

Атрибут ```--stat``` добавит иноформацию о количестве измененных файлов и количестве добавленных и удаленных строк.

Коммандой:

```git show <commit>```

можно просматривать конкретные коммиты.

## Графы коммитов

Коммиты внутри git связываются в один большой граф. Данный граф называется DAG графом(direct acyclic graph, направленый ациклический граф). В таком графе коммиты являются вершинами, которые имеют однонаправленую связь в виде ребра, от последнего коммита к предыдущему(предыдущим если 2 и более родителей).

DAG имеет два важных свойства:

1. Ребра однонаправлены

1. Если начать обход по ребрам с любой вершины, то обратного пути для возвращения в исходную вершину не существует.

На истори коммитов ниже, время идет слева на право. Но для гит не имеет значение когда были сделаны коммиты E и C. Коммиты могли быть сделаны в разных часовых поясах. 
Ветка master состоит из коммитов: A, B, C, D, H.
Ветка pr17  состоит из коммитов  A, B, E, F, G.

После слияния веток master будет указывать на коммит H, а pr17 так и будет указывать на G, как было до слияния.

```
         E<--F<--G 
        /         \
A <-- B<--C<--D<--H 

G - pr17 branch
H - master

```

### Диапазонны фиксаций



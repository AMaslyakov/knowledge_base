<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Теория - База знаний</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u0422\u0435\u043e\u0440\u0438\u044f";
        var mkdocs_page_input_path = "git.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> База знаний
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Главная</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Git</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Теория</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">Введение</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gitlinux">Пакеты git(linux)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#windows">Установка в Windows</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#git_1">Как хранятся изменения внутри git</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">Индекс</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">Идентификаторы объектов</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">Отслеживание контента</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#vs">Путь vs. Содержание</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pack-">Pack-файлы</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">Управление индексом</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#git-add">git add</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-commit">git commit</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-rm">git rm</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-mv">git mv</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gitignore">.gitignore</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#gitignore_1">Формат .gitignore</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">Приоритет игнорирования</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">Коммиты(фиксации)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_8">Атомарные наборы изменений</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">Исходное состояние</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#1">Пример 1: Неатомарный перенос (код не работает)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2">Пример 2: Атомарный перенос (код работает)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_10">Идентификация фиксаций.</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_11">Абсолютные имена фиксации</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">Ссылки и символьные ссылки</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">Специальные символьные ссылки</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">Относительные имена фиксаций</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_15">История фиксаций</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_16">Просмотр коммитов</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_17">Графы коммитов</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#dag">Понимание DAG коммитов</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_18">Диапазонны фиксаций</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_19">Достижимость в графах</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_20">Исключение коммитов и веток</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_21">Поиск коммитов</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../commands/">Справочник команд</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Java</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../spring/">Spring и Spring Boot</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">Абаут</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">База знаний</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Git</li>
      <li class="breadcrumb-item active">Теория</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="git">Git</h1>
<h2 id="_1">Введение</h2>
<p>Для любой разработки требуется сохранение кода и контроль версий.
Утилита которая позволяет управлять и отслеживать разными версиями кода называется системой контроля версий.</p>
<p>Рассмотрим программу git, для управления контролем версий. </p>
<h2 id="gitlinux">Пакеты git(linux)</h2>
<p>Для переноса из других vcs(version control system), могут потребоваться пакеты:</p>
<pre><code>git-arch
git-cvs
git-svn
</code></pre>
<p>Название пакетов в разных дистрибутивах могут отличаться.</p>
<p>Для графического представления истории репозитория могут пригодиться пакеты:</p>
<pre><code>git-gui
gitk
gitweb
</code></pre>
<p>Для отправки патчей посредством email понадобится пакет:</p>
<pre><code>git-email
</code></pre>
<h2 id="windows">Установка в Windows</h2>
<p>Для установки git в Windows. Можно установить:</p>
<p><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p>
<p>Либо Cygwing git:</p>
<p><a href="https://cygwing.com">https://cygwing.com</a></p>
<p>Либо пакет msysGit:</p>
<p><a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p>
<h2 id="git_1">Как хранятся изменения внутри git</h2>
<p>Данные репозитория хранятся в директории <code>.git</code>. Git управляет хранилищем объектов и индексом.</p>
<p>Хранилище объектов содержит четыре типа объектов:</p>
<ul>
<li>BLOB(Binary Large Object) содержит данные без метаданных</li>
<li>Деревья. Дерево представляет один уровень, записывает id блобов, имена путей, небольшие метаданные для всех файлов в каталоге</li>
<li>Коммиты хранят метаданные изменений(имя автора, дату, сообщение коммита) Каждый коммит ссылается на снимок состояния репозитория (объект дерева). Обычные коммиты имеют одного родителя, но возможны и коммиты с несколькими родителями (например, при слиянии веток).  </li>
<li>Теги человекочитаемое имя назначаемое объекту, обычно коммитам. Например Ver.-1.0</li>
</ul>
<h2 id="_2">Индекс</h2>
<p>В git это временный и динамический бинарный файл, который описывает структуру каталогов всего репозитория. В частности, индекс получает версию полной структуры проекта в некоторый момент времени.</p>
<p>Git позволяет изменять содержимое индекса четко определенными действиями.</p>
<p>Индекс хранит изменения до коммита.
Изменяется с помощью добавления, удаления, редактирования фпйлов.</p>
<h2 id="_3">Идентификаторы объектов</h2>
<p>Хранилище объектов git организовано в виде ассоциативной системы хранения. Каждому объекту присваивается уникальное имя - идентификатор, на основе алгоритма SHA1. Идентфикатор объекта представляется в виде 40-разрядного 16-ричного числа. Часто его еще называют <em>хэшкод</em>.
Хэшкод вычисляется на основе содержимого объекта. Если содержимое объектов идентично они имеют одинаковый хэшкод.</p>
<h2 id="_4">Отслеживание контента</h2>
<p>Благодаря идентификаторам, git может отслеживать контент. Если в репозитории существует два идентичных файла, то для них в хранилище будет создан один BLOB с хэшкодом вычисленным на основе содержимого.</p>
<p>Если один из файлов после изменений будет иметь отличия, соответственно создаться новый BLOB с новым идентификатором объекта.</p>
<h2 id="vs">Путь vs. Содержание</h2>
<p>Git имеет собственную структуру хранилища, которая не основывается на именах и путях файлов. Внутренняя структура git более эффективна для собственных операций над объектами. И она позволяет точно воспроизвести файлы и каталоги проекты проиндексированные хэшем.</p>
<h2 id="pack-">Pack-файлы</h2>
<p>Git умно упаковывает файлы. Он находит файлы похожие по содержанию и сохраняет полностью только один файл. Другой файл сохраняется в хранилище в виде дельты, т.е. сохраняется только разница содержимого между первым и вторым файлом.</p>
<h2 id="_5">Управление индексом</h2>
<p>Состояние индекса можно узнать в любой момент с помощью команды:</p>
<p><code>git status</code></p>
<p>Файлы классифицируются на:</p>
<ul>
<li>отслеживаемые(tracked)</li>
<li>игнорируемые(ignored)</li>
<li>неотслеживаемые(untracked)</li>
</ul>
<p><em>Отслеживаемые</em> файлы уже находятся в репозитории</p>
<p><em>Игнорируемые</em> явно объявленные файлы и деректории в .gitignore </p>
<p><em>Неотслеживаемые</em> файлы которые не добавлены в индекс и отсутствуют в .gitignore</p>
<h3 id="git-add">git add</h3>
<p>Добавляет файл(ы) в индекс. Т.е. файл(ы) становится отслеживаемым(и). Также добавляет изменения для уже отслеживаемых файлов.</p>
<h3 id="git-commit">git commit</h3>
<p>Производится фиксация изменений добавленных в индекс.</p>
<p>Команда <code>git commit --all</code> автоматически добавляет в индекс изменения отслеживаемых файлов и сразу создает коммит. Не отслеживаемые файлы при этом не меняют свой статус.</p>
<p>Если не указать опцию <code>-m</code> git запустит редактор указанный в конфигурации для создания коммита.</p>
<h3 id="git-rm">git rm</h3>
<p>Команда удаляет файлы из индекса и из каталога. Либо удаляет файлы только  из индекса. Не может удалить файлы только с диска(для этого нужно использовать системную команду), т.е. команда работает только с файлами добавленными в репозиторий.</p>
<p>Команда:</p>
<p><code>git rm --cached</code></p>
<p>Удаляет файл из индекса. Т.е. делает файл неотслеживаемым. </p>
<p>Но команда <code>git rm</code> удалит файл и из индекса и с диска до коммита и после коммита.</p>
<p>Команда:</p>
<p><code>git rm -f</code> </p>
<p>Удалит даже отслеживаемый модифицированный файл не добавленный в индекс.</p>
<p>Для восстановления файла удаленного командой <code>git rm</code> можно использовать механизм восстановления файлов:</p>
<p><code>git checkout HEAD -- &lt;file&gt;</code></p>
<h3 id="git-mv">git mv</h3>
<p>Позволяет перемещать и переименовывать файлы находящиеся репозитории или в индексе.</p>
<p>Синтаксис:</p>
<p><code>git mv  &lt;file1&gt; &lt;file2&gt;</code></p>
<h2 id="gitignore">.gitignore</h2>
<p>Содержит список файлов и шаблонов которые нужно игнорировать. </p>
<h3 id="gitignore_1">Формат .gitignore</h3>
<p><code># Files</code> -- комментарий</p>
<p><code>\#file.txt</code> -- если название файла начинается с решетки</p>
<p><code>file.txt</code> -- имена файлов полном виде</p>
<p><code>dir/</code> -- каталог отмечается следующим образом</p>
<p><code>*</code> -- заменяет любые символы</p>
<p>Например:</p>
<p><code>*.txt</code> -- игнорировать все файлы с расширением <code>.txt</code></p>
<p><code>!</code> -- задает исключение для общего правила заданного с помощью предшествующего правила.</p>
<p>Например:</p>
<pre><code>logs/
!logs/log.txt
</code></pre>
<p>Игнорирует папку logs и все содержимое, но отслеживает logs/log.txt</p>
<pre><code>*.txt
!history.txt
</code></pre>
<p>Игнорирует все файлы txt, но отслеживает history.txt</p>
<p>Файлы .gitignore можно создавать в любом каталоге репозитория. Каждый файл влияет только на свой каталог и все подкаталоги. Правила .gitignore каскадные, определив общее правило в каталоге высокого уровня, его можно отменять с помощью <code>!</code> в подкаталогах.</p>
<h3 id="_6">Приоритет игнорирования</h3>
<ul>
<li>Шаблоны определенные в командной строке ???</li>
<li>Шаблоны из файла в верхнем каталоге</li>
<li>Шаблоны в родительских каталогах, они будут перезаписаны с помощью .gitignore более высокого уровня</li>
<li>Шаблоны из файла <code>.git/info/exclude</code></li>
<li>Шаблоны из файла указанного переменной конфигурации <code>core.excludefile</code>  </li>
</ul>
<p><em>exclude</em> -- содержит шаблоны как и в .gitignore. Позволяет игнорировать специфичные файлы характерные для операционной системы или ПО, но в .gitignore репозитория отмечать файлы характерные только для его специфики.</p>
<h2 id="_7">Коммиты(фиксации)</h2>
<p>Коммит это добавление изменений в репозитрий. Git сравнивает ткущее состояние индекса с предыдущим и получает список добавленых/измененых/удаленных файлов
/каталогов. Если файл/каталог изменился создается новый BLOB, если не изменился используются имеющиеся блобы.</p>
<p>Коммиты объденяются в цепочку, в которой каждый новый коммит указывает на превдшественика.</p>
<p>Коммит это единственный способ представления изменений в репозиторий.</p>
<p>Git нормально относится к частым коммитам и обеспечивает богатый набор комманд для управления ими.</p>
<h3 id="_8">Атомарные наборы изменений</h3>
<p>Разработчик отправляющий изменения в репозиторий должен стремится чтобы каждый коммит представлял собой атомарный(неделимый) набор изменений не зависимо от количества созданых/модифицированных/удаленных файлов/каталогов. </p>
<p>Пример на Python, иллюстрирующий разницу между неатомарным и атомарным переносом функции между файлами:</p>
<h3 id="_9">Исходное состояние</h3>
<p><strong>file_a.py</strong></p>
<pre><code class="language-python">def foo():
    print(&quot;foo из file_a&quot;)

def bar():
    print(&quot;bar из file_a&quot;)
</code></pre>
<p><strong>file_b.py</strong></p>
<pre><code class="language-python">def baz():
    print(&quot;baz из file_b&quot;)
</code></pre>
<p><strong>main.py</strong></p>
<pre><code class="language-python">from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
</code></pre>
<h2 id="1">Пример 1: Неатомарный перенос (код не работает)</h2>
<p><strong>Шаг 1.</strong> Удаляем функцию <code>foo</code> из <code>file_a.py</code> (делаем коммит).</p>
<p><strong>file_a.py</strong></p>
<pre><code class="language-python">def bar():
    print(&quot;bar из file_a&quot;)
</code></pre>
<p><strong>file_b.py</strong> (без изменений)</p>
<pre><code class="language-python">def baz():
    print(&quot;baz из file_b&quot;)
</code></pre>
<p><strong>main.py</strong> (без изменений)</p>
<pre><code class="language-python">from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
</code></pre>
<p><strong>Результат:</strong><br />
При запуске <code>main.py</code> возникает ошибка:</p>
<blockquote>
<p>ImportError: cannot import name 'foo' from 'file_a'</p>
</blockquote>
<p><strong>Причина:</strong><br />
Функция удалена, но импорт в main.py не изменён. Код не работает.</p>
<h2 id="2">Пример 2: Атомарный перенос (код работает)</h2>
<p><strong>Шаг 1.</strong> Переносим функцию <code>foo</code> в <code>file_b.py</code> и корректируем все импорты (делаем один атомарный коммит).</p>
<p><strong>file_a.py</strong></p>
<pre><code class="language-python">def bar():
    print(&quot;bar из file_a&quot;)
</code></pre>
<p><strong>file_b.py</strong></p>
<pre><code class="language-python">def baz():
    print(&quot;baz из file_b&quot;)

def foo():
    print(&quot;foo из file_b&quot;)
</code></pre>
<p><strong>main.py</strong></p>
<pre><code class="language-python">from file_a import bar
from file_b import baz, foo

foo()
bar()
baz()
</code></pre>
<p><strong>Результат:</strong><br />
Код запускается без ошибок, все функции доступны и работают как ожидается.</p>
<p><strong>Вывод:</strong><br />
В первом случае коммит неатомарный — функция удалена, но не добавлена в новый файл и не исправлены импорты, из-за чего код ломается.<br />
Во втором случае коммит атомарный — все изменения внесены одновременно, код всегда находится в рабочем состоянии. </p>
<p>Git все равно как сделан коммит, но если не учитывать атомарность фиксаций, репозиторий будет иметь переходные состояния.</p>
<h2 id="_10">Идентификация фиксаций.</h2>
<p>Как и любой объект в git коммит имеет идентификатор - хэш-код.</p>
<p>Идентификаторы нужны для создания веток, для сравнения двух веток, для 
изменения истории коммитов</p>
<h3 id="_11">Абсолютные имена фиксации</h3>
<p>Хэш-код коммита -- это абсолютное имя которое относится только к одному коммиту. Такой идентификатор <em>глобален</em>. Если есть два коммитс с одинаковым именем в двух разных репозиториях, это значит что их содержимое одинаково.</p>
<p>Для удобства 40-значное абсолютное имя коммита сокращается до 6 знаков при использовании коммандами Git. </p>
<pre><code>git log -1 --pretty=oneline HEAD
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
</code></pre>
<pre><code>git log -1 --pretty=oneline 3e7d33
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
</code></pre>
<h3 id="_12">Ссылки и символьные ссылки</h3>
<p>Хэшкод является ссылкой относящейся к объекту.</p>
<p>Символическая ссылка это имя коссвенно указывающее на объект.</p>
<p>Локальные имена ветки, удаленные имена ветки, имена тэгов -- все это ссылки.</p>
<p>У символической ссылки есть явное - полное имя, которое хранится в каталоге .git/refs/</p>
<p>Обычно представлено три пространства имен:
- refs/heads/refs - локальные ветки
- refs/remotes/ref - удаленные ветки 
- refs/tag/ref - теги</p>
<p>Например для локальной ветки dev, будет соотвеовать ссылка:</p>
<pre><code>refs/heads/dev
</code></pre>
<p>Для удаленой ветки origin/master, соответсовать:</p>
<pre><code>refs/remotes/origin/master
</code></pre>
<p>Для тега v2.6.23, будет соотвествовать ссылка:</p>
<pre><code>refs/tags/v2.6.23
</code></pre>
<p>Если тег и ветка будут иметь одинаковые имена, то порядок поиска ссылок будет проходить как:</p>
<ul>
<li>.git/ref(Для специальных ссылок HEAD, ORIG_HEAD...)</li>
<li>.git/refs/ref</li>
<li>.git/refs/tags/ref</li>
<li>.git/refs/heads/ref</li>
<li>.git/refs/remotes/ref</li>
<li>.git/refs/remotes/ref/HEAD</li>
</ul>
<h3 id="_13">Специальные символьные ссылки</h3>
<p><strong>HEAD</strong> указывает на самую последнюю фиксацию в текущей ветке. 
За исключением ситуации, detach HEAD, при переключении на какой-либо коммит. Detach HEAD будет указывать на переключенный коммит. detach -- говорит о том, что HEAD не прикреплен к конкретной ветке.</p>
<p><strong>ORIG_HEAD</strong> такие операции как merge revert записывают предыдущию версию HEAD в ORIG_HEAD. Данную ссылку можно использовать для восстановления предыдущего состяния или сравнения.</p>
<p><strong>FETCH_HEAD</strong> сюда команда <code>git fetch</code> записывает головы всех удаленных веток. Ссылка доступна после опреции fetch</p>
<p><strong>MERGE_HEAD</strong> указывает на вершину ветки с которой было сделано слияние. Ссылка доступна после слияния.</p>
<p>Все символические ссылки управляются командой <code>git symbolic-ref</code> </p>
<h3 id="_14">Относительные имена фиксаций</h3>
<p>Для быстрого выполнения команд и навигации между комиттами git предлагает механизм относительных имен. С помощью символово <code>~</code> и <code>^</code>.</p>
<p>Совместно с этими символами можно использовать символьные ссылки <code>HEAD</code>, имена веток, сокращенный хэшкод.</p>
<p>Предыдущий коммит в main:</p>
<p><code>main^</code> или <code>main~</code> или <code>main~1</code></p>
<p>Предыдущий от предидущего:</p>
<p><code>main^^</code> или <code>main~2</code></p>
<p>При слиянии у коммттов могут образовываться родители 2 и болле. <code>^</code> используется для навигации по родителям коммта. 
Первый родитель коммита:</p>
<p><code>main^</code> или <code>main^1</code></p>
<p>Второй родитель коммита:</p>
<p><code>main^2</code> </p>
<p>Данные обозначения можно комбинировать. Например:</p>
<p><code>main~9^2~3^4</code></p>
<p>Используя:</p>
<p><code>git show-branch --more=10</code></p>
<p>Можно изучать структуру графа репозитория и иследовать слодные слияния. </p>
<h2 id="_15">История фиксаций</h2>
<h3 id="_16">Просмотр коммитов</h3>
<p>Основная команда для просмотра коммитов:</p>
<p><code>git log</code></p>
<p>Запись без параметров аналгоична комманде:</p>
<p><code>git log HEAD</code></p>
<p>Выводит исторю коммитов в обратном хронологическом порядке, от коммита HEAD. Но нужно помниить, что при перемещении по истории ккоммитов git придерживается их графика, а не времени.</p>
<p>Вывод <code>git log</code> можно менять с помощью аргумента <code>--pretty</code>. Можно выбрать формат вывода из готовых вартантов (full, short, oneline). Или задать формат с помощью значения format.</p>
<p>Примеры:</p>
<p><code>git log --pretty=short main</code></p>
<pre><code>commit f068b66b1332771771ddc0cbdf55da2ac4c4add5
Author: AMaslyakov &lt;A.V.Masliakov@urfu.me&gt;

    Relative names
</code></pre>
<p><code>git log --pretty=format:"Хэш: %H сокращенный хэш:%h"</code></p>
<p><code>Хэш: f068b66b1332771771ddc0cbdf55da2ac4c4add5, сокращелнный хэш: f068b66</code></p>
<p>Можно ограничить вывод истории между несколькими коммитами:</p>
<p><code>git log --pretty=short  main~12..main~10</code></p>
<p>Покажет историю между 10-м и 11-м коммитом в main в формате 
short.</p>
<p>Комманда:</p>
<p><code>git log -1 -p 4а3688</code></p>
<p>Выведет изменения созданные в коммите</p>
<p>Атрибут <code>--stat</code> добавит иноформацию о количестве измененных файлов и количестве добавленных и удаленных строк.</p>
<p>Коммандой:</p>
<p><code>git show &lt;commit&gt;</code></p>
<p>можно просматривать конкретные коммиты.</p>
<h2 id="_17">Графы коммитов</h2>
<p>Коммиты внутри git связываются в один большой граф. Данный граф называется DAG графом(direct acyclic graph, направленый ациклический граф). В таком графе коммиты являются вершинами, которые имеют однонаправленую связь в виде ребра, от последнего коммита к предыдущему(предыдущим если 2 и более родителей).</p>
<p>DAG имеет два важных свойства:</p>
<ol>
<li>
<p>Ребра однонаправлены</p>
</li>
<li>
<p>Если начать обход по ребрам с любой вершины, то обратного пути для возвращения в исходную вершину не существует.</p>
</li>
</ol>
<p>На истори коммитов ниже, время идет слева на право. Но для гит не имеет значение когда были сделаны коммиты E и C. Коммиты могли быть сделаны в разных часовых поясах. 
Ветка master состоит из коммитов: A, B, C, D, H.
Ветка pr17  состоит из коммитов  A, B, E, F, G.</p>
<p>После слияния веток master будет указывать на коммит H, а pr17 так и будет указывать на G, как было до слияния.</p>
<pre><code>         E&lt;--F&lt;--G 
        /         \
A &lt;-- B&lt;--C&lt;--D&lt;--H 

G - pr17 branch
H - master

</code></pre>
<h3 id="dag">Понимание DAG коммитов</h3>
<ul>
<li>
<p>У каждого коммита может быть 0 и более родителей</p>
</li>
<li>
<p>У обычных коммитов есть только один родитель</p>
</li>
<li>
<p>У начальной фиксации(коммита) нет родителей, т.е. их 0</p>
</li>
<li>
<p>У merge коммита болле одного родителя</p>
</li>
<li>
<p>Коммит у которого два и более  потомка(ребенка/children) формирует ветку. Для примера выше это коммит B</p>
</li>
</ul>
<h3 id="_18">Диапазонны фиксаций</h3>
<p>Для изучения ветки или части ветки, в гит можно использовать диапазоны коммитов. Рассмотрим пример для ветки M.</p>
<p><code>M~14&lt;-M~13&lt;-M~12&lt;-M~11-M~10&lt;-M~9</code></p>
<p>Где <code>M~14</code> самый старый коммит на даннм отрезке ветки, а <code>M~9</code> самый новый на данном отрезке</p>
<p>Диапазон коммитов обозначается как <code>&lt;start&gt;..&lt;end&gt;</code> например:</p>
<p><code>M~12..M~10</code> -- что соответствует двум коммитам <code>M~10, M~11</code>. <code>M~12</code>не включен в диапазон. Так устроенно из-за определения диапазона коммитов в git -- это набор коммитов достижимых с конца(end), но не достижимых с начала(start). Другими словами end, включен в диапазон, а start не включен. 
Математически:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo>(</mo>
  <mi>start</mi>
  <mo>;</mo>
  <mi>end</mi>
  <mo>]</mo>
</math>

<p>При этом напрвление start end соотвесьвуют хронологическому порядку. Start старше, чем end. Но при этом не включение start в диапазон, обозначает направление связей от end в сторону старших коммитов.</p>
<h2 id="_19">Достижимость в графах</h2>
<p>Коммит X достижим из коммита Y, когда можно пойти из коммита Y по дугам графа, по направления ребер и прийти в коммит X.</p>
<p>Достижимость коммитов используется например для комманды <code>git log</code>.</p>
<p>Пусть имеется репозиторй с двумя ветками: mian и branch. Произведено слияние из branch в main.Тогда:</p>
<pre><code>            D(branch)  
           /   \    
A &lt;- B &lt;- C &lt;-  E &lt;- F(main)
</code></pre>
<p>Команда <code>git log main</code> выведет исторю для всех достижимых узлов: F, E, D, C, B, A. </p>
<p>Команда <code>git log branch</code>выведет историю для достижимых узлов: D, C, B, A.</p>
<p>Пусть имеется репозиторй с двумя ветками: mian и branch. Но слияние произведено из main в branch.Тогда:</p>
<pre><code>            D &lt;- G(branch)  
           /     /  
A &lt;- B &lt;- C &lt;-  E &lt;- F(main)
</code></pre>
<p>Команда <code>git log main</code> покажет историю из: F, E, C, B, A. Коммиты D, G будут не достижимы из F.</p>
<p>Команда <code>git log branch</code> покажет историю из: G, E, D, C, B, A. Из G будет не достижим только коммит F.</p>
<h3 id="_20">Исключение коммитов и веток</h3>
<p>Для того чтобы исключить коммит и все достижимые из него узлы используется префикс <code>^</code>(в отличие от постфикса, указание на родителя).</p>
<p>Например для ветки:</p>
<p><code>A &lt;- B &lt;- C &lt;- main</code></p>
<p><code>git log ^B main</code></p>
<p>Будет выведено: main, C.</p>
<p>При этом порядок не важен:
                              │  <code>git log  main ^B</code></p>
<p>Данная команда эквивалентна команде:</p>
<p><code>git log B..main</code></p>
<p>Рассмотрим диапазон конкретнее на других примерах.</p>
<pre><code>      &lt;-G&lt;-D(branch)
           /(merge to branch)   
A &lt;- B &lt;- C &lt;-  E &lt;- F(main)

</code></pre>
<p>Команда <code>git log branch..main</code> выведет: F(main), E.
Все узлы достижимые из branch, включая узел C в котором ветка branch была создана, будут исключены. </p>
<p>Для случая:</p>
<pre><code>    W&lt;-X&lt;-Y &lt;-Z (branch)
      /        \
A &lt;- B &lt;- C &lt;-  D(main)

</code></pre>
<p>Команда <code>git log branch..main</code> выведет: D(main), C. Потомучто все узлы достижимые из branch будут исключены, в том числе и Z(branch)</p>
<p>Диапазон можно задавать в коротком варианте: <code>start..</code>, <code>..end</code>. Что эквивалентно <code>start..HEAD</code>, <code>HEAD..end</code> соотвественно.</p>
<p>Так же запись диапазонна можно рассматривать как разницу:</p>
<p><code>A &lt;- B &lt;- C &lt;- main</code></p>
<p><code>git log B..main</code></p>
<p>```A - B
          C - main </p>
<pre><code>
### Симметричный диапазон(симметричная разница)

Получается с помощью символа ```a...b``` - троеточие. Выводит те узлы которые доступны только  из start или доступны только из end, но не одновременно. При этом узлы a, b не являбтся ни концом ни началом. Поэтому  ```b...a``` будет эквивалентно ```a...b```

</code></pre>
<p>A &lt;- B &lt;- C &lt;- D&lt;- E &lt;-F&lt;-G(main)
              \      /
               U &lt;- V &lt;-X &lt;-Y(dev)
```</p>
<p>Из main достижимы:
(G), (F), V, U, C, (E), (D), B, A
Из dev достижимы|
(Y), (X), V, U, C, B, A.</p>
<p>в скобках помечены коммиты, которых нет в другой ветке.</p>
<p>Соответсвенно команда <code>git log dev...main</code>, выведет коммииты: D, E, F, X, Y, G</p>
<h2 id="_21">Поиск коммитов</h2>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Главная"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../commands/" class="btn btn-neutral float-right" title="Справочник команд">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../commands/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

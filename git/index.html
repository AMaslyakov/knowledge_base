<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Теория - База знаний</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u0422\u0435\u043e\u0440\u0438\u044f";
        var mkdocs_page_input_path = "git.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> База знаний
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Главная</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Git</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Теория</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">Введение</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gitlinux">Пакеты git(linux)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#windows">Установка в Windows</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#git_1">Как хранятся изменения внутри git</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">Индекс</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">Идентификаторы объектов</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">Отслеживание контента</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#vs">Путь vs. Содержание</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pack-">Pack-файлы</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">Управление индексом</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#git-add">git add</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-commit">git commit</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-rm">git rm</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-mv">git mv</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gitignore">.gitignore</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#gitignore_1">Формат .gitignore</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">Приоритет игнорирования</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">Коммиты(фиксации)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_8">Атомарные наборы изменений</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">Исходное состояние</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#1">Пример 1: Неатомарный перенос (код не работает)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2">Пример 2: Атомарный перенос (код работает)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_10">Идентификация фиксаций.</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_11">Абсолютные имена фиксации</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">Ссылки и символьные ссылки</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">Специальные символьные ссылки</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">Относительные имена фиксаций</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_15">История фиксаций</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_16">Просмотр коммитов</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_17">Графы коммитов</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#dag">Понимание DAG коммитов</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_18">Диапазонны фиксаций</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_19">Достижимость в графах</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_20">Исключение коммитов и веток</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_21">Симметричный диапазон(симметричная разница)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_22">Поиск коммитов</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#git-bisect">git bisect</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_23">Принцип работы</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_24">Основные команды</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#git-bisect_1">Пример использования git bisect</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#git-bisect-run">Автоматизация тестирования через git bisect run</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_25">Итоги</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git-blame">git blame</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pickaxe">Pickaxe</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../commands/">Справочник команд</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Java</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../spring/">Spring и Spring Boot</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">Абаут</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">База знаний</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Git</li>
      <li class="breadcrumb-item active">Теория</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="git">Git</h1>
<h2 id="_1">Введение</h2>
<p>Для любой разработки требуется сохранение кода и контроль версий.
Утилита которая позволяет управлять и отслеживать разными версиями кода называется системой контроля версий.</p>
<p>Рассмотрим программу git, для управления контролем версий. </p>
<h2 id="gitlinux">Пакеты git(linux)</h2>
<p>Для переноса из других vcs(version control system), могут потребоваться пакеты:</p>
<pre><code>git-arch
git-cvs
git-svn
</code></pre>
<p>Название пакетов в разных дистрибутивах могут отличаться.</p>
<p>Для графического представления истории репозитория могут пригодиться пакеты:</p>
<pre><code>git-gui
gitk
gitweb
</code></pre>
<p>Для отправки патчей посредством email понадобится пакет:</p>
<pre><code>git-email
</code></pre>
<h2 id="windows">Установка в Windows</h2>
<p>Для установки git в Windows. Можно установить:</p>
<p><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p>
<p>Либо Cygwing git:</p>
<p><a href="https://cygwing.com">https://cygwing.com</a></p>
<p>Либо пакет msysGit:</p>
<p><a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p>
<h2 id="git_1">Как хранятся изменения внутри git</h2>
<p>Данные репозитория хранятся в директории <code>.git</code>. Git управляет хранилищем объектов и индексом.</p>
<p>Хранилище объектов содержит четыре типа объектов:</p>
<ul>
<li>BLOB(Binary Large Object) содержит данные без метаданных</li>
<li>Деревья. Дерево представляет один уровень, записывает id блобов, имена путей, небольшие метаданные для всех файлов в каталоге</li>
<li>Коммиты хранят метаданные изменений(имя автора, дату, сообщение коммита) Каждый коммит ссылается на снимок состояния репозитория (объект дерева). Обычные коммиты имеют одного родителя, но возможны и коммиты с несколькими родителями (например, при слиянии веток).  </li>
<li>Теги человекочитаемое имя назначаемое объекту, обычно коммитам. Например Ver.-1.0</li>
</ul>
<h2 id="_2">Индекс</h2>
<p>В git это временный и динамический бинарный файл, который описывает структуру каталогов всего репозитория. В частности, индекс получает версию полной структуры проекта в некоторый момент времени.</p>
<p>Git позволяет изменять содержимое индекса четко определенными действиями.</p>
<p>Индекс хранит изменения до коммита.
Изменяется с помощью добавления, удаления, редактирования фпйлов.</p>
<h2 id="_3">Идентификаторы объектов</h2>
<p>Хранилище объектов git организовано в виде ассоциативной системы хранения. Каждому объекту присваивается уникальное имя - идентификатор, на основе алгоритма SHA1. Идентфикатор объекта представляется в виде 40-разрядного 16-ричного числа. Часто его еще называют <em>хэшкод</em>.
Хэшкод вычисляется на основе содержимого объекта. Если содержимое объектов идентично они имеют одинаковый хэшкод.</p>
<h2 id="_4">Отслеживание контента</h2>
<p>Благодаря идентификаторам, git может отслеживать контент. Если в репозитории существует два идентичных файла, то для них в хранилище будет создан один BLOB с хэшкодом вычисленным на основе содержимого.</p>
<p>Если один из файлов после изменений будет иметь отличия, соответственно создаться новый BLOB с новым идентификатором объекта.</p>
<h2 id="vs">Путь vs. Содержание</h2>
<p>Git имеет собственную структуру хранилища, которая не основывается на именах и путях файлов. Внутренняя структура git более эффективна для собственных операций над объектами. И она позволяет точно воспроизвести файлы и каталоги проекты проиндексированные хэшем.</p>
<h2 id="pack-">Pack-файлы</h2>
<p>Git умно упаковывает файлы. Он находит файлы похожие по содержанию и сохраняет полностью только один файл. Другой файл сохраняется в хранилище в виде дельты, т.е. сохраняется только разница содержимого между первым и вторым файлом.</p>
<h2 id="_5">Управление индексом</h2>
<p>Состояние индекса можно узнать в любой момент с помощью команды:</p>
<p><code>git status</code></p>
<p>Файлы классифицируются на:</p>
<ul>
<li>отслеживаемые(tracked)</li>
<li>игнорируемые(ignored)</li>
<li>неотслеживаемые(untracked)</li>
</ul>
<p><em>Отслеживаемые</em> файлы уже находятся в репозитории</p>
<p><em>Игнорируемые</em> явно объявленные файлы и деректории в .gitignore </p>
<p><em>Неотслеживаемые</em> файлы которые не добавлены в индекс и отсутствуют в .gitignore</p>
<h3 id="git-add">git add</h3>
<p>Добавляет файл(ы) в индекс. Т.е. файл(ы) становится отслеживаемым(и). Также добавляет изменения для уже отслеживаемых файлов.</p>
<h3 id="git-commit">git commit</h3>
<p>Производится фиксация изменений добавленных в индекс.</p>
<p>Команда <code>git commit --all</code> автоматически добавляет в индекс изменения отслеживаемых файлов и сразу создает коммит. Не отслеживаемые файлы при этом не меняют свой статус.</p>
<p>Если не указать опцию <code>-m</code> git запустит редактор указанный в конфигурации для создания коммита.</p>
<h3 id="git-rm">git rm</h3>
<p>Команда удаляет файлы из индекса и из каталога. Либо удаляет файлы только  из индекса. Не может удалить файлы только с диска(для этого нужно использовать системную команду), т.е. команда работает только с файлами добавленными в репозиторий.</p>
<p>Команда:</p>
<p><code>git rm --cached</code></p>
<p>Удаляет файл из индекса. Т.е. делает файл неотслеживаемым. </p>
<p>Но команда <code>git rm</code> удалит файл и из индекса и с диска до коммита и после коммита.</p>
<p>Команда:</p>
<p><code>git rm -f</code> </p>
<p>Удалит даже отслеживаемый модифицированный файл не добавленный в индекс.</p>
<p>Для восстановления файла удаленного командой <code>git rm</code> можно использовать механизм восстановления файлов:</p>
<p><code>git checkout HEAD -- &lt;file&gt;</code></p>
<h3 id="git-mv">git mv</h3>
<p>Позволяет перемещать и переименовывать файлы находящиеся репозитории или в индексе.</p>
<p>Синтаксис:</p>
<p><code>git mv  &lt;file1&gt; &lt;file2&gt;</code></p>
<h2 id="gitignore">.gitignore</h2>
<p>Содержит список файлов и шаблонов которые нужно игнорировать. </p>
<h3 id="gitignore_1">Формат .gitignore</h3>
<p><code># Files</code> -- комментарий</p>
<p><code>\#file.txt</code> -- если название файла начинается с решетки</p>
<p><code>file.txt</code> -- имена файлов полном виде</p>
<p><code>dir/</code> -- каталог отмечается следующим образом</p>
<p><code>*</code> -- заменяет любые символы</p>
<p>Например:</p>
<p><code>*.txt</code> -- игнорировать все файлы с расширением <code>.txt</code></p>
<p><code>!</code> -- задает исключение для общего правила заданного с помощью предшествующего правила.</p>
<p>Например:</p>
<pre><code>logs/
!logs/log.txt
</code></pre>
<p>Игнорирует папку logs и все содержимое, но отслеживает logs/log.txt</p>
<pre><code>*.txt
!history.txt
</code></pre>
<p>Игнорирует все файлы txt, но отслеживает history.txt</p>
<p>Файлы .gitignore можно создавать в любом каталоге репозитория. Каждый файл влияет только на свой каталог и все подкаталоги. Правила .gitignore каскадные, определив общее правило в каталоге высокого уровня, его можно отменять с помощью <code>!</code> в подкаталогах.</p>
<h3 id="_6">Приоритет игнорирования</h3>
<ul>
<li>Шаблоны определенные в командной строке ???</li>
<li>Шаблоны из файла в верхнем каталоге</li>
<li>Шаблоны в родительских каталогах, они будут перезаписаны с помощью .gitignore более высокого уровня</li>
<li>Шаблоны из файла <code>.git/info/exclude</code></li>
<li>Шаблоны из файла указанного переменной конфигурации <code>core.excludefile</code>  </li>
</ul>
<p><em>exclude</em> -- содержит шаблоны как и в .gitignore. Позволяет игнорировать специфичные файлы характерные для операционной системы или ПО, но в .gitignore репозитория отмечать файлы характерные только для его специфики.</p>
<h2 id="_7">Коммиты(фиксации)</h2>
<p>Коммит это добавление изменений в репозитрий. Git сравнивает ткущее состояние индекса с предыдущим и получает список добавленых/измененых/удаленных файлов
/каталогов. Если файл/каталог изменился создается новый BLOB, если не изменился используются имеющиеся блобы.</p>
<p>Коммиты объденяются в цепочку, в которой каждый новый коммит указывает на превдшественика.</p>
<p>Коммит это единственный способ представления изменений в репозиторий.</p>
<p>Git нормально относится к частым коммитам и обеспечивает богатый набор комманд для управления ими.</p>
<h3 id="_8">Атомарные наборы изменений</h3>
<p>Разработчик отправляющий изменения в репозиторий должен стремится чтобы каждый коммит представлял собой атомарный(неделимый) набор изменений не зависимо от количества созданых/модифицированных/удаленных файлов/каталогов. </p>
<p>Пример на Python, иллюстрирующий разницу между неатомарным и атомарным переносом функции между файлами:</p>
<h3 id="_9">Исходное состояние</h3>
<p><strong>file_a.py</strong></p>
<pre><code class="language-python">def foo():
    print(&quot;foo из file_a&quot;)

def bar():
    print(&quot;bar из file_a&quot;)
</code></pre>
<p><strong>file_b.py</strong></p>
<pre><code class="language-python">def baz():
    print(&quot;baz из file_b&quot;)
</code></pre>
<p><strong>main.py</strong></p>
<pre><code class="language-python">from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
</code></pre>
<h2 id="1">Пример 1: Неатомарный перенос (код не работает)</h2>
<p><strong>Шаг 1.</strong> Удаляем функцию <code>foo</code> из <code>file_a.py</code> (делаем коммит).</p>
<p><strong>file_a.py</strong></p>
<pre><code class="language-python">def bar():
    print(&quot;bar из file_a&quot;)
</code></pre>
<p><strong>file_b.py</strong> (без изменений)</p>
<pre><code class="language-python">def baz():
    print(&quot;baz из file_b&quot;)
</code></pre>
<p><strong>main.py</strong> (без изменений)</p>
<pre><code class="language-python">from file_a import foo, bar
from file_b import baz

foo()
bar()
baz()
</code></pre>
<p><strong>Результат:</strong><br />
При запуске <code>main.py</code> возникает ошибка:</p>
<blockquote>
<p>ImportError: cannot import name 'foo' from 'file_a'</p>
</blockquote>
<p><strong>Причина:</strong><br />
Функция удалена, но импорт в main.py не изменён. Код не работает.</p>
<h2 id="2">Пример 2: Атомарный перенос (код работает)</h2>
<p><strong>Шаг 1.</strong> Переносим функцию <code>foo</code> в <code>file_b.py</code> и корректируем все импорты (делаем один атомарный коммит).</p>
<p><strong>file_a.py</strong></p>
<pre><code class="language-python">def bar():
    print(&quot;bar из file_a&quot;)
</code></pre>
<p><strong>file_b.py</strong></p>
<pre><code class="language-python">def baz():
    print(&quot;baz из file_b&quot;)

def foo():
    print(&quot;foo из file_b&quot;)
</code></pre>
<p><strong>main.py</strong></p>
<pre><code class="language-python">from file_a import bar
from file_b import baz, foo

foo()
bar()
baz()
</code></pre>
<p><strong>Результат:</strong><br />
Код запускается без ошибок, все функции доступны и работают как ожидается.</p>
<p><strong>Вывод:</strong><br />
В первом случае коммит неатомарный — функция удалена, но не добавлена в новый файл и не исправлены импорты, из-за чего код ломается.<br />
Во втором случае коммит атомарный — все изменения внесены одновременно, код всегда находится в рабочем состоянии. </p>
<p>Git все равно как сделан коммит, но если не учитывать атомарность фиксаций, репозиторий будет иметь переходные состояния.</p>
<h2 id="_10">Идентификация фиксаций.</h2>
<p>Как и любой объект в git коммит имеет идентификатор - хэш-код.</p>
<p>Идентификаторы нужны для создания веток, для сравнения двух веток, для 
изменения истории коммитов</p>
<h3 id="_11">Абсолютные имена фиксации</h3>
<p>Хэш-код коммита -- это абсолютное имя которое относится только к одному коммиту. Такой идентификатор <em>глобален</em>. Если есть два коммитс с одинаковым именем в двух разных репозиториях, это значит что их содержимое одинаково.</p>
<p>Для удобства 40-значное абсолютное имя коммита сокращается до 6 знаков при использовании коммандами Git. </p>
<pre><code>git log -1 --pretty=oneline HEAD
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
</code></pre>
<pre><code>git log -1 --pretty=oneline 3e7d33
3e7d33c63a50fffbebd7dde0ffd2b7d0210c537a Commits
</code></pre>
<h3 id="_12">Ссылки и символьные ссылки</h3>
<p>Хэшкод является ссылкой относящейся к объекту.</p>
<p>Символическая ссылка это имя коссвенно указывающее на объект.</p>
<p>Локальные имена ветки, удаленные имена ветки, имена тэгов -- все это ссылки.</p>
<p>У символической ссылки есть явное - полное имя, которое хранится в каталоге .git/refs/</p>
<p>Обычно представлено три пространства имен:
- refs/heads/refs - локальные ветки
- refs/remotes/ref - удаленные ветки 
- refs/tag/ref - теги</p>
<p>Например для локальной ветки dev, будет соотвеовать ссылка:</p>
<pre><code>refs/heads/dev
</code></pre>
<p>Для удаленой ветки origin/master, соответсовать:</p>
<pre><code>refs/remotes/origin/master
</code></pre>
<p>Для тега v2.6.23, будет соотвествовать ссылка:</p>
<pre><code>refs/tags/v2.6.23
</code></pre>
<p>Если тег и ветка будут иметь одинаковые имена, то порядок поиска ссылок будет проходить как:</p>
<ul>
<li>.git/ref(Для специальных ссылок HEAD, ORIG_HEAD...)</li>
<li>.git/refs/ref</li>
<li>.git/refs/tags/ref</li>
<li>.git/refs/heads/ref</li>
<li>.git/refs/remotes/ref</li>
<li>.git/refs/remotes/ref/HEAD</li>
</ul>
<h3 id="_13">Специальные символьные ссылки</h3>
<p><strong>HEAD</strong> указывает на самую последнюю фиксацию в текущей ветке. 
За исключением ситуации, detach HEAD, при переключении на какой-либо коммит. Detach HEAD будет указывать на переключенный коммит. detach -- говорит о том, что HEAD не прикреплен к конкретной ветке.</p>
<p><strong>ORIG_HEAD</strong> такие операции как merge revert записывают предыдущию версию HEAD в ORIG_HEAD. Данную ссылку можно использовать для восстановления предыдущего состяния или сравнения.</p>
<p><strong>FETCH_HEAD</strong> сюда команда <code>git fetch</code> записывает головы всех удаленных веток. Ссылка доступна после опреции fetch</p>
<p><strong>MERGE_HEAD</strong> указывает на вершину ветки с которой было сделано слияние. Ссылка доступна после слияния.</p>
<p>Все символические ссылки управляются командой <code>git symbolic-ref</code> </p>
<h3 id="_14">Относительные имена фиксаций</h3>
<p>Для быстрого выполнения команд и навигации между комиттами git предлагает механизм относительных имен. С помощью символово <code>~</code> и <code>^</code>.</p>
<p>Совместно с этими символами можно использовать символьные ссылки <code>HEAD</code>, имена веток, сокращенный хэшкод.</p>
<p>Предыдущий коммит в main:</p>
<p><code>main^</code> или <code>main~</code> или <code>main~1</code></p>
<p>Предыдущий от предидущего:</p>
<p><code>main^^</code> или <code>main~2</code></p>
<p>При слиянии у коммттов могут образовываться родители 2 и болле. <code>^</code> используется для навигации по родителям коммта. 
Первый родитель коммита:</p>
<p><code>main^</code> или <code>main^1</code></p>
<p>Второй родитель коммита:</p>
<p><code>main^2</code> </p>
<p>Данные обозначения можно комбинировать. Например:</p>
<p><code>main~9^2~3^4</code></p>
<p>Используя:</p>
<p><code>git show-branch --more=10</code></p>
<p>Можно изучать структуру графа репозитория и иследовать слодные слияния. </p>
<h2 id="_15">История фиксаций</h2>
<h3 id="_16">Просмотр коммитов</h3>
<p>Основная команда для просмотра коммитов:</p>
<p><code>git log</code></p>
<p>Запись без параметров аналгоична комманде:</p>
<p><code>git log HEAD</code></p>
<p>Выводит исторю коммитов в обратном хронологическом порядке, от коммита HEAD. Но нужно помниить, что при перемещении по истории ккоммитов git придерживается их графика, а не времени.</p>
<p>Вывод <code>git log</code> можно менять с помощью аргумента <code>--pretty</code>. Можно выбрать формат вывода из готовых вартантов (full, short, oneline). Или задать формат с помощью значения format.</p>
<p>Примеры:</p>
<p><code>git log --pretty=short main</code></p>
<pre><code>commit f068b66b1332771771ddc0cbdf55da2ac4c4add5
Author: AMaslyakov &lt;A.V.Masliakov@urfu.me&gt;

    Relative names
</code></pre>
<p><code>git log --pretty=format:"Хэш: %H сокращенный хэш:%h"</code></p>
<p><code>Хэш: f068b66b1332771771ddc0cbdf55da2ac4c4add5, сокращелнный хэш: f068b66</code></p>
<p>Можно ограничить вывод истории между несколькими коммитами:</p>
<p><code>git log --pretty=short  main~12..main~10</code></p>
<p>Покажет историю между 10-м и 11-м коммитом в main в формате 
short.</p>
<p>Комманда:</p>
<p><code>git log -1 -p 4а3688</code></p>
<p>Выведет изменения созданные в коммите</p>
<p>Атрибут <code>--stat</code> добавит иноформацию о количестве измененных файлов и количестве добавленных и удаленных строк.</p>
<p>Коммандой:</p>
<p><code>git show &lt;commit&gt;</code></p>
<p>можно просматривать конкретные коммиты.</p>
<h2 id="_17">Графы коммитов</h2>
<p>Коммиты внутри git связываются в один большой граф. Данный граф называется DAG графом(direct acyclic graph, направленый ациклический граф). В таком графе коммиты являются вершинами, которые имеют однонаправленую связь в виде ребра, от последнего коммита к предыдущему(предыдущим если 2 и более родителей).</p>
<p>DAG имеет два важных свойства:</p>
<ol>
<li>
<p>Ребра однонаправлены</p>
</li>
<li>
<p>Если начать обход по ребрам с любой вершины, то обратного пути для возвращения в исходную вершину не существует.</p>
</li>
</ol>
<p>На истори коммитов ниже, время идет слева на право. Но для гит не имеет значение когда были сделаны коммиты E и C. Коммиты могли быть сделаны в разных часовых поясах. 
Ветка master состоит из коммитов: A, B, C, D, H.
Ветка pr17  состоит из коммитов  A, B, E, F, G.</p>
<p>После слияния веток master будет указывать на коммит H, а pr17 так и будет указывать на G, как было до слияния.</p>
<pre><code>         E&lt;--F&lt;--G 
        /         \
A &lt;-- B&lt;--C&lt;--D&lt;--H 

G - pr17 branch
H - master

</code></pre>
<h3 id="dag">Понимание DAG коммитов</h3>
<ul>
<li>
<p>У каждого коммита может быть 0 и более родителей</p>
</li>
<li>
<p>У обычных коммитов есть только один родитель</p>
</li>
<li>
<p>У начальной фиксации(коммита) нет родителей, т.е. их 0</p>
</li>
<li>
<p>У merge коммита болле одного родителя</p>
</li>
<li>
<p>Коммит у которого два и более  потомка(ребенка/children) формирует ветку. Для примера выше это коммит B</p>
</li>
</ul>
<h3 id="_18">Диапазонны фиксаций</h3>
<p>Для изучения ветки или части ветки, в гит можно использовать диапазоны коммитов. Рассмотрим пример для ветки M.</p>
<p><code>M~14&lt;-M~13&lt;-M~12&lt;-M~11-M~10&lt;-M~9</code></p>
<p>Где <code>M~14</code> самый старый коммит на даннм отрезке ветки, а <code>M~9</code> самый новый на данном отрезке</p>
<p>Диапазон коммитов обозначается как <code>&lt;start&gt;..&lt;end&gt;</code> например:</p>
<p><code>M~12..M~10</code> -- что соответствует двум коммитам <code>M~10, M~11</code>. <code>M~12</code>не включен в диапазон. Так устроенно из-за определения диапазона коммитов в git -- это набор коммитов достижимых с конца(end), но не достижимых с начала(start). Другими словами end, включен в диапазон, а start не включен. 
Математически:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo>(</mo>
  <mi>start</mi>
  <mo>;</mo>
  <mi>end</mi>
  <mo>]</mo>
</math>

<p>При этом напрвление start end соотвесьвуют хронологическому порядку. Start старше, чем end. Но при этом не включение start в диапазон, обозначает направление связей от end в сторону старших коммитов.</p>
<h2 id="_19">Достижимость в графах</h2>
<p>Коммит X достижим из коммита Y, когда можно пойти из коммита Y по дугам графа, по направления ребер и прийти в коммит X.</p>
<p>Достижимость коммитов используется например для комманды <code>git log</code>.</p>
<p>Пусть имеется репозиторй с двумя ветками: mian и branch. Произведено слияние из branch в main.Тогда:</p>
<pre><code>            D(branch)  
           /   \    
A &lt;- B &lt;- C &lt;-  E &lt;- F(main)
</code></pre>
<p>Команда <code>git log main</code> выведет исторю для всех достижимых узлов: F, E, D, C, B, A. </p>
<p>Команда <code>git log branch</code>выведет историю для достижимых узлов: D, C, B, A.</p>
<p>Пусть имеется репозиторй с двумя ветками: mian и branch. Но слияние произведено из main в branch.Тогда:</p>
<pre><code>            D &lt;- G(branch)  
           /     /  
A &lt;- B &lt;- C &lt;-  E &lt;- F(main)
</code></pre>
<p>Команда <code>git log main</code> покажет историю из: F, E, C, B, A. Коммиты D, G будут не достижимы из F.</p>
<p>Команда <code>git log branch</code> покажет историю из: G, E, D, C, B, A. Из G будет не достижим только коммит F.</p>
<h3 id="_20">Исключение коммитов и веток</h3>
<p>Для того чтобы исключить коммит и все достижимые из него узлы используется префикс <code>^</code>(в отличие от постфикса, указание на родителя).</p>
<p>Например для ветки:</p>
<p><code>A &lt;- B &lt;- C &lt;- main</code></p>
<p><code>git log ^B main</code></p>
<p>Будет выведено: main, C.</p>
<p>При этом порядок не важен:
                                <code>git log  main ^B</code></p>
<p>Данная команда эквивалентна команде:</p>
<p><code>git log B..main</code></p>
<p>Рассмотрим диапазон конкретнее на других примерах.</p>
<pre><code>      &lt;-G&lt;-D(branch)
           /(merge to branch)   
A &lt;- B &lt;- C &lt;-  E &lt;- F(main)

</code></pre>
<p>Команда <code>git log branch..main</code> выведет: F(main), E.
Все узлы достижимые из branch, включая узел C в котором ветка branch была создана, будут исключены. </p>
<p>Для случая:</p>
<pre><code>    W&lt;-X&lt;-Y &lt;-Z (branch)
      /        \
A &lt;- B &lt;- C &lt;-  D(main)

</code></pre>
<p>Команда <code>git log branch..main</code> выведет: D(main), C. Потомучто все узлы достижимые из branch будут исключены, в том числе и Z(branch)</p>
<p>Диапазон можно задавать в коротком варианте: <code>start..</code>, <code>..end</code>. Что эквивалентно <code>start..HEAD</code>, <code>HEAD..end</code> соотвественно.</p>
<p>Так же запись диапазонна можно рассматривать как разницу:</p>
<p><code>A &lt;- B &lt;- C &lt;- main</code></p>
<p><code>git log B..main</code></p>
<p><code>A &lt;- B
          C - main</code></p>
<h3 id="_21">Симметричный диапазон(симметричная разница)</h3>
<p>Получается с помощью символа <code>a...b</code> - троеточие. Выводит те узлы которые доступны только  из start или доступны только из end, но не одновременно. При этом узлы a, b не являбтся ни концом ни началом. Поэтому  <code>b...a</code> будет эквивалентно <code>a...b</code></p>
<pre><code>A &lt;- B &lt;- C &lt;- D&lt;- E &lt;-F&lt;-G(main)
              \      /
               U &lt;- V &lt;-X &lt;-Y(dev)
</code></pre>
<p>Из main достижимы:
(G), (F), V, U, C, (E), (D), B, A
Из dev достижимы|
(Y), (X), V, U, C, B, A.</p>
<p>в скобках помечены коммиты, которых нет в другой ветке.</p>
<p>Соответсвенно команда <code>git log dev...main</code>, выведет коммииты: D, E, F, X, Y, G</p>
<h2 id="_22">Поиск коммитов</h2>
<h3 id="git-bisect">git bisect</h3>
<p><code>git bisect</code> — это инструмент Git для <strong>поиска коммита, в котором впервые появился баг или регрессия</strong>. Он использует <strong>бинарный поиск</strong> по истории коммитов, что позволяет значительно сократить время поиска проблемного изменения.</p>
<h4 id="_23">Принцип работы</h4>
<ol>
<li>Вы указываете два коммита:</li>
<li><strong>Хороший (good)</strong> — коммит, в котором баг отсутствует.</li>
<li>
<p><strong>Плохой (bad)</strong> — коммит, в котором баг уже наблюдается.</p>
</li>
<li>
<p>Git автоматически выбирает коммит примерно посередине между этими двумя точками и переключается на него.</p>
</li>
<li>
<p>Вы тестируете этот коммит:</p>
</li>
<li>Если баг есть — отмечаете его как <code>bad</code>.</li>
<li>
<p>Если баг отсутствует — как <code>good</code>.</p>
</li>
<li>
<p>Git снова выбирает точку посередине оставшегося диапазона и продолжает этот процесс пока не найдет <strong>первый плохой коммит</strong>, который и ввел баг.</p>
</li>
<li>
<p>После нахождения коммита процесс завершается, и вы можете проанализировать этот конкретный коммит.</p>
</li>
</ol>
<h4 id="_24">Основные команды</h4>
<ul>
<li><code>git bisect start</code> — начало работы с bisect.</li>
<li><code>git bisect bad [&lt;commit&gt;]</code> — указываете плохой коммит (если не указать, текущий considered bad).</li>
<li><code>git bisect good &lt;commit&gt;</code> — указываете хороший коммит.</li>
<li><code>git bisect reset</code> — завершение работы и возврат к изначальному состоянию.</li>
</ul>
<h4 id="git-bisect_1">Пример использования <code>git bisect</code></h4>
<p>Представим, что у вас есть баг в текущем состоянии ветки (<code>HEAD</code>), а в одном из старых коммитов бага точно не было.</p>
<pre><code class="language-bash"># Запускаем bisect-сессию
git bisect start

# Помечаем текущий коммит как плохой, т.к. баг виден здесь
git bisect bad

# Помечаем старый коммит как хороший, там баг не встречался
git bisect good &lt;good-commit-hash&gt;
</code></pre>
<p>Git перейдет на коммит посередине между этими двумя, и вы должны проверить его. Допустим, баг присутствует, значит:</p>
<pre><code class="language-bash">git bisect bad
</code></pre>
<p>Если бага нет, то:</p>
<pre><code class="language-bash">git bisect good
</code></pre>
<p>Git снова выберет коммит посредине оставшегося диапазона и переключится на него для проверки. Вы повторяете проверку и маркировку до тех пор, пока Git не укажет:</p>
<pre><code>&lt;commit-hash&gt; is the first bad commit
</code></pre>
<p>После этого желательно завершить bisect:</p>
<pre><code class="language-bash">git bisect reset
</code></pre>
<h4 id="git-bisect-run">Автоматизация тестирования через <code>git bisect run</code></h4>
<p>Если у вас есть команда или скрипт для автоматического теста проекта (например, сборка и запуск тестов), то можно использовать:</p>
<pre><code class="language-bash">git bisect start
git bisect bad
git bisect good &lt;good-commit&gt;
git bisect run &lt;тестовая команда или скрипт&gt;
</code></pre>
<p>Git автоматически будет запускать тест на каждом коммите, помечая его как хороший или плохой в зависимости от результата. Это ускоряет процесс и минимизирует ручную работу.</p>
<h4 id="_25">Итоги</h4>
<ul>
<li><code>git bisect</code> оптимизирует поиск проблемного коммита с помощью бинарного поиска.</li>
<li>Позволяет находить баги или регрессии быстро даже в длинной истории.</li>
<li>Поддерживает ручной и автоматический режим тестирования.</li>
<li>После завершения bisect вы получаете точный коммит, который впервые вызвал проблему.</li>
</ul>
<h3 id="git-blame">git blame</h3>
<p><strong>git blame</strong> — команда Git для показа, кто и когда последний раз изменял каждую строку выбранного файла. В выводе для каждой строки отображаются:</p>
<ul>
<li><strong>SHA-1 хэш коммита</strong></li>
<li><strong>Автор</strong></li>
<li><strong>Дата и время изменения</strong></li>
<li><strong>Собственно строка кода</strong></li>
</ul>
<p>Это основной инструмент для исследований истории кода: позволяет быстро выяснить, кто ответственен за конкретные изменения — например, чтобы задать вопросы о найденном баге или понять причину правок</p>
<p>Основной синтаксис:</p>
<pre><code class="language-bash">git blame &lt;имя_файла&gt;
</code></pre>
<p>Популярные опции:</p>
<ul>
<li><code>-L &lt;start&gt;,&lt;end&gt;</code> — аннотация только определенного диапазона строк</li>
<li><code>-e</code> — отображение email вместо имени автора</li>
<li><code>-C</code> и <code>-M</code> — отслеживание перемещенных или скопированных строк между файлами для более точной истории</li>
<li><code>-w</code> — игнорировать изменения только в пробелах</li>
</ul>
<p><code>git blame</code> помогает ориентироваться в коде совместимых проектов, позволяет выявлять причину ошибок и отслеживать историю появления строк даже после рефакторинга или форматирования кода</p>
<p><strong>Пример вывода</strong>:</p>
<pre><code>301b7eca (ivanov   2023-04-01 14:12:41 +0300 10) print('Hello, world!')
</code></pre>
<p>Здесь указаны хэш коммита, автор с датой и изменённая строка</p>
<h3 id="pickaxe">Pickaxe</h3>
<p><strong>Pickaxe</strong> — это внутренняя функция в Git, реализованная с помощью опций команд, таких как <strong>-S</strong> и <strong>-G</strong>, обычно используемых в командах <code>git log</code>, <code>git diff</code>, <code>git show</code> для поиска изменений определённого текста в истории коммитов.</p>
<ul>
<li>Опция <strong>-S&lt;строка&gt;</strong> ищет коммиты, в которых количество вхождений заданной строки изменилось (то есть строка была добавлена или удалена) — подходит для поиска, когда и где появился или исчез кусок кода</li>
<li>Опция <strong>-G&lt;регулярное-выражение&gt;</strong> находит коммиты, где в патче добавились или удалились строки, соответствующие данному регулярному выражению</li>
</ul>
<p>Флаг <code>--pickaxe-regex</code> используется вместе с <strong>-S</strong> для того, чтобы строка воспринималась как регулярное выражение.</p>
<p><strong>Пример поиска появления/удаления строки:</strong></p>
<pre><code class="language-bash">git log -S&quot;some_function&quot; --oneline
</code></pre>
<p>Этот запрос покажет коммиты, в которых была добавлена или удалена строка, содержащая "some_function".</p>
<p>Pickaxe помогает разработчикам "раскопать" историю изменений определённого участка кода, особенно эффективно работает для анализа появления или исчезновения ключевых фрагментов</p>
<h1 id="git_2">Ветки Git</h1>
<p>Ветка git это фундаментальное понятие -- отделение разработки в отдельную линию которая не будет затрагивать основную main(master).</p>
<h2 id="_26">Причины использования веток</h2>
<ul>
<li>Отдельные версии программ</li>
<li>Ветка может представлять этап разработки</li>
<li>Изолировать разработку, для внесения новых функций, тестирования, исправления ошибок</li>
<li>Отдельная ветка может преставлять отдельного программиста</li>
</ul>
<h2 id="branch-vs-tag">Branch vs. tag</h2>
<p>Ветка перемещается вместе с коммитами. Имя ветки всегда указывает на последний коммит ветки.</p>
<p>Тег статическое имя определенного коммита. Он никак не изменяется при добавлении новых изменений.</p>
<p>В репозитории git  могут находиться и тег и ветка с одинаковыми именами. При обращении к такомумимени, git переколчит на ветку и выведет сообщение о неоднозначности в репозитории. Для переключение на тег или ветку в этом случае следует использовать:</p>
<pre><code class="language-bash">git checkout refs/tags/&lt;name&gt;
git checkout refs/heads/&lt;name&gt;
</code></pre>
<h2 id="_27">Имена веток</h2>
<p>Ветка может имет любое имя, но с рядом ограничений:</p>
<p>В репозитории всегда есть главная ветка: main или master. Она может быть переименована при необходимости.</p>
<p>Правила:</p>
<p>Имя не может содержать:</p>
<ul>
<li><code>..</code> две последовательные точки</li>
<li>пробел или пробельный символ</li>
<li>спецсимволы git: <code>~ ^ : ? * [</code></li>
<li>управляющие символы ASCII  </li>
<li><code>-</code> знак минус первым символом</li>
<li>Знак <code>/</code> последним символом</li>
</ul>
<h3 id="_28">Иерархические имена</h3>
<p>Такие имена содержат слэш <code>/</code> это позволяет объеденять ветки в пространство имен.</p>
<p>Например ветки c префиксом bug, будут означать, что в этих ветках устранаяют и тестируют баги.
Ветка с префиксом dev означает что там ведется разработка и т.д.</p>
<p>Например:</p>
<pre><code class="language-bash">git branch &quot;bug/strange-things&quot;
git branch &quot;bug/something&quot;
</code></pre>
<p>По мимо разделения пространства имен, такие ветки улучшают навигацию по репозиторию.</p>
<p>Например можно вывести информацию о всех ветках с префиксои bug:</p>
<p><code>git show-branch bug/*</code></p>
<h2 id="_29">Работа с ветками</h2>
<p>В репозитории может быть множество веток, но только одна ветка активна. </p>
<p>Коммиты добавляются в активную ветку. Имя ветки указывает на последний коммит(HEAD) в ней. </p>
<p>Репозиторий git не хранит информацию о том где началась ветка. Новые фиксации создаются на новой ветке. Но благодоря DAG, можно найти коммит алгоритмически от которого произоша новая ветка. В git это делает команда: </p>
<p><code>git merge-base main new-branch</code></p>
<p>Имена веток и содержимое коммитов локально для репозитория. </p>
<p>Можно пересылать в удаленный репозиторий одну или несколько веток. Публикация ветки должна быть явной.</p>
<h3 id="_30">Создание веток</h3>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Главная"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../commands/" class="btn btn-neutral float-right" title="Справочник команд">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../commands/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
